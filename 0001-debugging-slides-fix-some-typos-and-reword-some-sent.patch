From 941b1ece3fd3efb060eb21b34b654d40dc8db808 Mon Sep 17 00:00:00 2001
From: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date: Thu, 22 Aug 2024 08:40:04 +0200
Subject: [PATCH] debugging: slides: fix some typos and reword some sentences

Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
---
 .../debugging-system-wide-profiling.tex              | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/slides/debugging-system-wide-profiling/debugging-system-wide-profiling.tex b/slides/debugging-system-wide-profiling/debugging-system-wide-profiling.tex
index 34b9ad6e..0b687ee4 100644
--- a/slides/debugging-system-wide-profiling/debugging-system-wide-profiling.tex
+++ b/slides/debugging-system-wide-profiling/debugging-system-wide-profiling.tex
@@ -1034,7 +1034,7 @@ $ lttng create my-session --set-url=net://remote-system
     has been added in kernel 3.18 but it is still evolving and receiving
     updates frequently.
     \item eBPF programs can capture and expose kernel data to userspace, and
-    also alter kernel behavior based on some used-defined rules.
+    also alter kernel behavior based on some user-defined rules.
     \item eBPF is event-driven: an eBPF program is triggered and executed on a
     specific kernel event
     \item A major benefit from eBPF is the possibility to reprogram the kernel
@@ -1129,7 +1129,7 @@ $ lttng create my-session --set-url=net://remote-system
       \item an arbitrary kprobe
       \item a kernel-defined static tracepoint
       \item a specific perf event
-      \item a xdp hook (incoming packet entry point)
+      \item throughout the network stack
       \item and a lot more, see \ksym{bpf_attach_type}
     \end{itemize}
     \item A specific attach-point type can only be hooked with a set of
@@ -1187,7 +1187,7 @@ $ lttng create my-session --set-url=net://remote-system
     \item The syscall works with file descriptors pointing to eBPF resources.
     Those resources (program, maps, links, etc) remain valid while there is at least
     one program holding a valid file descriptor to it. Those are automatically cleaned
-    once there are no user anymore.
+    once there are no user left.
     \item For more details, see  \manpage{bpf}{2}
   \end{itemize}
 \end{frame}
@@ -1196,7 +1196,7 @@ $ lttng create my-session --set-url=net://remote-system
   \frametitle{Writing eBPF programs}
   \begin{itemize}
     \item eBPF programs can either be written directly in raw eBPF assembly or in
-    higher level languages (e.g: C or rust), and are compiled using clang
+    higher level languages (e.g: C or rust), and are compiled using the clang
     compiler.
     \item In order to be accepted by the verifier, the program must follow some
     design rules: limited stack size, no unbound loops, checking pointers before dereferencing...
@@ -1227,7 +1227,7 @@ $ lttng create my-session --set-url=net://remote-system
       userspace program
       \item One can also use \code{bpftool} on the built ebpf program to
       manipulate it (load, attach, read maps, etc), without writing any userspace tool
-      \item Or can we write our own ebpf tool thanks to some intermediate libraries which handle most of the
+      \item Or we can write our own eBPF tool thanks to some intermediate libraries which handle most of the
       hard work, like libbpf
       \item We can also use specialized frameworks like BCC or bpftrace to really
       get all operations (bpf program build included) handled
@@ -1344,7 +1344,7 @@ b.attach_kprobe(event=b.get_syscall_fnname("clone"), fn_name="hello")
 \begin{frame}[fragile]
   \frametitle{libbpf}
   \begin{itemize}
-    \item Instead of using high level framework like BCC, one can use libbpf to
+    \item Instead of using a high level framework like BCC, one can use libbpf to
     build custom tools with a finer control on every aspect of the program.
     \item libbpf is a C-based library that aims to ease eBPF programming thanks
     to the following features:
-- 
2.45.2

