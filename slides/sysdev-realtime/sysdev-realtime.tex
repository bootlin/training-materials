\section{Real-time in embedded Linux systems}

\subsection{Introduction}

\begin{frame}
  \frametitle{Embedded Linux and real time}
  \begin{itemize}
  \item Due to its advantages, Linux and open-source software are more
    and more commonly used in embedded applications
  \item However, some applications also have real-time constraints
  \item They, at the same time, want to
    \begin{itemize}
    \item Get all the nice advantages of Linux: hardware support,
      components re-use, low cost, etc.
    \item Get their real-time constraints met
    \end{itemize}
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{slides/sysdev-realtime/linux-vs-realtime.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Embedded Linux and real time}
  \begin{itemize}
  \item Linux is an operating system part of the large UNIX family
  \item It was originally designed as a time-sharing system
    \begin{itemize}
    \item The main goal was to get the best throughput from the
      available hardware, by making the best possible usage of
      resources (CPU, memory, I/O)
    \item Time determinism was not taken into account
    \end{itemize}
  \item On the opposite, real-time constraints imply time determinism,
    even at the expense of lower global throughput
  \item Best throughput and time determinism are contradictory
    requirements
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux and real-time approaches (1)}
  \begin{itemize}
  \item Over time, two major approaches have been taken to bring
    real-time requirements into Linux
  \item {\bf Approach 1}
    \begin{itemize}
    \item Improve the Linux kernel itself so that it matches real-time
      requirements, by providing bounded latencies, real-time APIs,
      etc.
    \item Approach taken by the mainline Linux kernel and the
      {\bf PREEMPT\_RT} project.
    \end{itemize}
  \item {\bf Approach 2}
    \begin{itemize}
    \item Add a layer below the Linux kernel that will handle all the
      real-time requirements, so that the behavior of Linux doesn't
      affect real-time tasks.
    \item Approach taken by RTLinux, RTAI and {\bf Xenomai}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux and real-time approaches (2)}
  \begin{columns}
  \column{0.7\textwidth}
  \small
  An alternative approach is to use specific hardware to run real-time
  work on:
  \begin{itemize}
  \item Dedicating a CPU core to running a separate real-time OS or
    bare-metal real-time application, without Linux control.
  \item Running real-time work on an FPGA

  \item Running real-time work on a dedicated microcontroller
    \begin{itemize}
    \item Can be a separate micro-controller
    \item Can be a micro-controller embedded in the main
      system-on-chip: PRU (Programmable Real-Time Unit) on TI AM335x,
      Cortex-M4 co-processors on NXP i.MX or STM32MP1 processors,
      etc.
    \end{itemize}
  \end{itemize}
  This section will not cover such approaches: we will limit ourselves
  to approaches where Linux is in full control of the system,
  including all the real-time processing.
  \column{0.3\textwidth}
  \includegraphics[width=\textwidth]{slides/sysdev-realtime/stm32mp157-with-m4.jpg}\\
  \tiny STM32MP157 SoC block diagram
  \end{columns}
\end{frame}

\subsection[PREEMPT\_RT Patches]{Improving the mainline Linux kernel with
  PREEMPT\_RT}

\begin{frame}
  \frametitle{Understanding latency}
  \begin{itemize}
  \item When developing real-time applications with a system such as
    Linux, the typical scenario is the following
    \begin{itemize}
    \item An event from the physical world happens and gets notified
      to the CPU by means of an interrupt
    \item The interrupt handler recognizes and handles the event, and
      then wake-up the user space task that will react to this event
    \item Some time later, the user space task will run and be able to
      react to the physical world event
    \end{itemize}
  \item Real-time is about providing guaranteed worst case latencies
    for this reaction time, called latency
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/latency-basic.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Linux kernel latency components}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/latency.pdf}\\
    kernel latency = interrupt latency + handler duration + scheduler
    latency + scheduler duration
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Interrupt latency}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/latency-highlight-interrupt-latency.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Sources of interrupt latency}
  There can be multiple causes delaying the execution of an interrupt
  handler.
  \begin{itemize}
    \item Interrupts disabled by evil drivers. Such drivers may still
	  exist but can be fixed.
    \item Already running interrupt handlers. In Linux, there are
	  no nested interrupts. Only one interrupt handler can run
	  at the same time on a given CPU core. Therefore, your critical
	  interrupt handler may wait for the completion of another,
	  non-critical handler.\\
	  Solution: make interrupt handlers run as quickly as possible.
    \item Sections of kernel code when disabling interrupts is
          necessary, typically in some {\em spinlocks}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Disabling interrupts in spinlocks (1)}
  \begin{itemize}
  \item One of the concurrency prevention mechanism used in the kernel
    is the {\bf spinlock}
  \item It has several variants, but one commonly used is
    to prevent concurrent accesses between a process context and an
    interrupt context works by disabling interrupts
  \item We want to avoid situations in which the interrupt handler
    waits forever for a spinlock that was held by the code it
    interrupted:
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{common/spinlock-deadlock-with-interrupt.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Disabling interrupts in spinlocks (2)}
  \begin{itemize}
  \item To avoid such issues, when there can be concurrency between regular kernel code
        and interrupt code, spinlocks are held with interrupts disabled.
  \item This can delay the execution of a critical interrupt handler
  \item The duration of these critical sections in which spinlocks are
        held with interrupts disabled is unbounded:
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/spinlock.pdf}
  \end{center}
\end{frame}

\begin{frame}
\frametitle{Interrupt handler duration}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/latency-highlight-interrupt-duration.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Interrupt handler implementation}
  \begin{itemize}
  \item In Linux, many interrupt handlers are split in two parts
    \begin{itemize}
    \item A top-half, started by the CPU as soon as interrupts are
      enabled. It runs with the interrupt line disabled and is
      supposed to complete as quickly as possible.
    \item A bottom-half, scheduled by the top-half, which starts after
      all pending top-halves have completed their execution.
    \end{itemize}
  \item Therefore, for real-time critical interrupts, bottom-halves
    shouldn't be used: their execution is delayed by all other
    interrupts in the system.
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/bottom-half-problem.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Scheduler latency}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/latency-highlight-scheduler-latency.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Understanding preemption (1)}
  \begin{itemize}
  \item The Linux kernel is a preemptive operating system
  \item When a task runs in user space mode and gets interrupted by an
    interruption, if the interrupt handler wakes up another task, this
    task can be scheduled as soon as we return from the interrupt
    handler.
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/userspace-preemption.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Understanding preemption (2)}
  \begin{itemize}
  \item However, when the interrupt comes while the task is executing
    a system call, this system call has to finish before another task
    can be scheduled.
  \item By default, the Linux kernel does not do kernel preemption.
  \item This means that the time before which the scheduler will be
    called to schedule another task is unbounded.
  \end{itemize}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/kernel-preemption.pdf}
  \end{center}
\end{frame}

\begin{frame}
\frametitle{Scheduler duration}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/latency-highlight-scheduler-duration.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Sources of scheduler duration}
  \begin{itemize}
     \item Before Linux 2.6, the execution time of the scheduler
	   depended on the number of processes on the system.
     \item Since Linux 2.6, the Linux kernel chooses the
	   next process to run in constant time ("O(1) scheduler"
           feature).
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Other non-deterministic mechanisms}
  Outside of the critical path detailed previously, other
  non-deterministic mechanisms of Linux can affect the execution
  time of real-time tasks
  \begin{itemize}
  \item Linux is highly based on virtual memory, as provided by an
    MMU, so that memory is allocated on demand. Whenever an
    application accesses code or data for the first time, it is loaded
    on demand, which can creates huge delays.
  \item Many C library services or kernel services are not designed
    with real-time constraints in mind.
  \item To avoid such sources of non-determinism, your system should allocate
    all the resources it needs ahead of time, before it is ready to react
    to events in a real-time way. For the virtual memory needs, it will
    be done through the \code{mlock()} and \code{mlockall()} system calls.
  \end{itemize}
  Issues can be addressed with a correct system design!
\end{frame}

\begin{frame}
  \frametitle{Priority inversion}

  A process with a low priority might hold a lock needed by a higher
  priority process, effectively reducing the priority of this
  process. Things can be even worse if a middle priority process uses
  the CPU.

  \begin{center}
    \includegraphics[height=0.45\textheight]{slides/sysdev-realtime/priority-inversion.pdf}
  \end{center}

  \small Best known case: Mars Pathfinder mission in 1997 (running VxWorks).\\
  See \url{https://www.embedded.com/introduction-to-priority-inversion/}
\end{frame}

\begin{frame}
  \frametitle{Interrupt handler priority}

  In Linux, interrupt handlers are executed directly by the CPU
  interrupt mechanisms, and not under control of the Linux
  scheduler. Therefore, all interrupt handlers have a higher priority
  than all tasks running on the system.

  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/interrupt-inversion.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{The PREEMPT\_RT project}
  \begin{itemize}
  \item Long-term project (started in 2004!) lead by Linux kernel developers
    such as Thomas Gleixner, Steven Rostedt and Ingo Molnar
    \begin{itemize}
    \item \url{https://wiki.linuxfoundation.org/realtime/}
    \end{itemize}
  \item The goal is to gradually improve the Linux kernel regarding
    real-time requirements and to get these improvements merged into
    the mainline kernel
    \begin{itemize}
    \item PREEMPT\_RT development works very closely with the mainline
      development
    \end{itemize}
  \item Many of the improvements designed, developed and debugged
    inside PREEMPT\_RT over the years are now part of the mainline
    Linux kernel
    \begin{itemize}
    \item The project is a long-term branch of the Linux kernel that
      ultimately should disappear as everything will have been merged
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Improvements to the mainline kernel}
  Brought by PREEMPT\_RT project since its beginning
  \begin{itemize}
  \item O(1) scheduler
  \item Kernel preemption
  \item Better POSIX real-time API support
  \item {\em ftrace} kernel function tracer
  \item Priority inheritance support for mutexes\\
	({\em mutex: MUTual EXclusion}, locking mechanims)
  \item High-resolution timers
  \item Threaded interrupts
  \item Spinlock annotations
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Preemption options}
  Preemption models offered by the mainline kernel (Linux 5.7 status):
  \begin{center}
    \includegraphics[width=0.9\textwidth]{slides/sysdev-realtime/mainline-preempt-options.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{1st option: no forced preemption}
  \kconfig{CONFIG_PREEMPT_NONE}\\
  Kernel code (interrupts, exceptions, system calls) never preempted.
  Default behavior in standard kernels.
  \begin{itemize}
  \item Best for systems making intense computations, on which overall
    throughput is key.
  \item Best to reduce task switching to maximize CPU and cache usage
    (by reducing context switching).
  \item Still benefits from some Linux real-time improvements: O(1)
    scheduler, increased multiprocessor safety (work on RT preemption
    was useful to identify hard to find SMP bugs).
  \item Can also benefit from a lower timer frequency (several possible
        values between 100 Hz and 1000 Hz).
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{2nd option: voluntary kernel preemption}
  \kconfig{CONFIG_PREEMPT_VOLUNTARY}\\
  Kernel code can preempt itself
  \begin{itemize}
  \item Typically for desktop systems, for quicker application
    reaction to user input.
  \item Adds explicit rescheduling points (\kfunc{might_sleep})
        throughout kernel code.
  \item Minor impact on throughput.
  \item Still used in: Ubuntu Desktop 20.04
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{3rd option: preemptible kernel}
  \kconfig{CONFIG_PREEMPT}\\
  Most kernel code can be involuntarily preempted at any time.  When a
  process becomes runnable, no more need to wait for kernel code
  (typically a system call) to return before running the scheduler.
  \begin{itemize}
  \item Exception: kernel critical sections (holding spinlocks):
  \begin{center}
    \includegraphics[width=0.9\textwidth]{common/spinlock-deadlock-with-preemption.pdf}
  \end{center}
  \item Typically for desktop or embedded systems with latency
    requirements in the milliseconds range. Still a relatively minor impact on throughput.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Priority inheritance}
  \begin{itemize}
  \item One classical solution to the priority inversion problem is
    called priority inheritance
    \includegraphics[height=0.45\textheight]{slides/sysdev-realtime/priority-inheritance.pdf}
  \item In the Linux kernel, mutexes support priority inheritance
  \item In user space, priority inheritance must be explicitly enabled
    on a per-mutex basis.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{High resolution timers}
  \begin{itemize}
  \item The resolution of the timers used to be bound to the
    resolution of the regular system tick
    \begin{itemize}
    \item Usually 100 Hz or 250 Hz, depending on the architecture and
      the configuration
    \item A resolution of only 10 ms or 4 ms.
    \item Increasing the regular system tick frequency is not an
      option as it would consume too many resources
    \end{itemize}
  \item The high-resolution timers infrastructure allows to use
    the available hardware timers to program interrupts
    at the right moment.
    \begin{itemize}
    \item Hardware timers are multiplexed, so that a single hardware
      timer is sufficient to handle a large number of
      software-programmed timers.
    \item Usable directly from user space using the usual timer APIs
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Threaded interrupts}
  \begin{itemize}
  \item To solve the interrupt inversion problem, PREEMPT\_RT has
    introduced the concept of threaded interrupts
  \item The interrupt handlers run in normal kernel threads, so that
    the priorities of the different interrupt handlers can be
    configured
  \item The real interrupt handler, as executed by the CPU, is only in
    charge of masking the interrupt and waking-up the corresponding
    thread
  \item The idea of threaded interrupts also allows to use sleeping
    spinlocks (see later)
  \item The conversion of interrupt handlers to
    threaded interrupts is not automatic: drivers must be modified
  \item In PREEMPT\_RT, all interrupt handlers are switched to
    threaded interrupts
  \end{itemize}
\end{frame}

\subsection{PREEMPT\_RT patchset specifics}

\begin{frame}
  \frametitle{New real-time preemption option (1)}
  The PREEMPT\_RT patchset adds one new level of preemption, \kconfig{CONFIG_PREEMPT_RT}:
  \begin{center}
    \includegraphics[height=0.4\textheight]{slides/sysdev-realtime/preempt-rt-option.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{New real-time preemption option (2)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/preempt-rt-option-help.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{{\tt CONFIG\_PREEMPT\_RT}}
  This level of preemption replaces all kernel spinlocks by
  mutexes (or so-called sleeping spinlocks)
  \begin{itemize}
  \item Instead of providing mutual exclusion by disabling
    interrupts and preemption, they are just normal locks: when
    contention happens, the process is blocked and another one is
    selected by the scheduler.
  \item Works well with threaded interrupts, since threads can
    block, while usual interrupt handlers could not.
  \item Some core, carefully controlled, kernel spinlocks remain as
    normal spinlocks ({\em spinlock annotations}: differentiation
    now in mainline between spinning spinlocks and those that can be
    converted to sleeping spinlocks).
  \item With \kconfig{CONFIG_PREEMPT_RT}, virtually all kernel code
    becomes preemptible
    \begin{itemize}
    \item An interrupt can occur at any time, when returning from the
      interrupt handler, the woken up process can start immediately.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Setting up PREEMPT\_RT}

\begin{frame}
  \frametitle{PREEMPT\_RT setup (1)}
  \begin{itemize}
  \item PREEMPT\_RT is delivered as a patch against the mainline
    kernel
    \begin{itemize}
    \item Only the latest and long term stable releases of the kernel
      are actively supported and maintained, currently: 5.12, 5.10, 5.4, 4.19,
      4.14, 4.9, 4.4. This is yet another advantage of using a mainline
      LTS kernel release! It will be difficult to port the patches to
      other kernel versions.
    \item Access to supported versions:
      \url{https://wiki.linuxfoundation.org/realtime/preempt_rt_versions}
    \end{itemize}
  \item Quick set up:
    \begin{itemize}
    \item Download the latest PREEMPT\_RT patch\\
      from \footnotesize \url{https://kernel.org/pub/linux/kernel/projects/rt/} \normalsize
    \item Download and extract the corresponding mainline kernel
      version
    \item Apply the patch to the mainline kernel tree
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{PREEMPT\_RT setup (2)}
  \begin{itemize}
  \item In the kernel configuration, be sure to enable
    \begin{itemize}
    \item \kconfig{CONFIG_PREEMPT_RT}
    \item High-resolution timers
    \end{itemize}
  \item Compile your kernel, and boot
  \item You are now running the real-time Linux kernel
  \item Of course, some system configuration remains to be done, in
    particular setting appropriate priorities to the interrupt
    threads, which depend on your application.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{PREEMPT\_RT mainlining status (1)}
  \begin{itemize}
  \item The project is making good progress since it got funding from
        the Linux Foundation in 2015 (Linux version 4.1 at that time).
  \item We can now observe a slow but steady reduction of the size of
        the PREEMPT\_RT patchset:\\
    \vfill
    \includegraphics[width=0.8\textwidth]{slides/sysdev-realtime/rt-patch-sizes.png}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{PREEMPT\_RT mainlining status (2)}
  \begin{itemize}
  \item However, the mainline Linux kernel is a moving target too,
        introducing new issues for real-time (such as disabling preemption in
        BPF... see \url{https://lwn.net/Articles/802884/}).
  \item In 5.12, new \kconfig{CONFIG_PREEMPT_DYNAMIC} switch to change the preemption
        model at boot time: \code{preempt=none}, \code{preempt=voluntary} or
        \code{preempt=full}
  \item In 5.15, the realtime preemption locking core is merged in mainline.
	This was the biggest part to mainline. A few pending changes are
	still left. See \url{https://lwn.net/Articles/867919/}.
  \item See the latest news on \url{https://wiki.linuxfoundation.org/realtime/}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Useful resources}
  About real-time support in the standard Linux kernel
  \begin{itemize}
  \item All LWN.net articles about Linux and real-time:\\
	\url{https://lwn.net/Kernel/Index/\#Realtime}
  \item A realtime's developer checklist, John Ogness and Marta Rybczyńska:\\
	\url{https://lwn.net/Articles/837019/}
  \item Real-Time is coming to Linux - What does that mean for you,\\
        Steven Rostedt, ELCE 2018:\\
	\url{https://www.elinux.org/images/7/7e/Rostedt-elc-eu-2018-rt-what-does-it-mean.pdf}\\
	Video: \url{https://youtu.be/BxJm-Ujipcg}
  \item The home page of the PREEMPT\_RT project:\\
       \url{https://wiki.linuxfoundation.org/realtime/}
  \end{itemize}
\end{frame}

\subsection{Real-time application development with PREEMPT\_RT}

\begin{frame}
  \frametitle{Development and compilation}
  \begin{itemize}
  \item No special library is needed, the POSIX real-time API is part
    of the standard C library
  \item The glibc C library is recommended, as support
    for some real-time features is not mature in other C libraries
    \begin{itemize}
    \item Priority inheritance mutexes or NPTL on some architectures,
      for example
    \end{itemize}
  \item Compile a program
    \begin{itemize}
    \item \code{ARCH-linux-gcc -o myprog myprog.c -lrt}
    \end{itemize}
  \item To get the documentation of the POSIX API
    \begin{itemize}
    \item Install the \code{manpages-posix-dev} package
    \item Run \code{man function-name}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Process, thread?}
  \begin{itemize}
  \item Confusion about the terms {\em process}, {\em thread} and {\em task}
  \item In UNIX, a process is created using \code{fork()} and is composed of
    \begin{itemize}
    \item An address space, which contains the program code, data, stack, shared
      libraries, etc.
    \item One thread, that starts executing the \code{main()} function.
    \item Upon creation, a process contains one thread
    \end{itemize}
  \item Additional threads can be created inside an existing process, using
    \code{pthread_create()}
    \begin{itemize}
    \item They run in the same address space as the initial thread of
      the process
    \item They start executing a function passed as argument to
      \code{pthread_create()}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Process, thread: kernel point of view}
  \begin{itemize}
  \item The kernel represents each thread running in the system by
    a \kstruct{task_struct} structure.
  \item From a scheduling point of view, it makes no difference
    between the initial thread of a process and all additional threads
    created dynamically using \code{pthread_create()}
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{slides/sysdev-realtime/thread-vs-process.pdf}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creating threads}
  \begin{itemize}
  \item Linux supports the POSIX thread API
  \item To create a new thread
    \begin{block}{}
\small
\begin{verbatim}
pthread_create(pthread_t *thread, pthread_attr_t *attr,
               void *(*routine)(void*), void *arg);
\end{verbatim}
\normalsize
    \end{block}
  \item The new thread will run in the same address space, but will be
    scheduled independently
  \item Exiting from a thread
    \begin{block}{}
\small
\begin{verbatim}
pthread_exit(void *value_ptr);
\end{verbatim}
\normalsize
    \end{block}
  \item Waiting for the termination of a thread
    \begin{block}{}
\small
\begin{verbatim}
pthread_join(pthread_t *thread, void **value_ptr);
\end{verbatim}
\normalsize
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}
  The Linux kernel scheduler supports different scheduling classes
  \frametitle{Scheduling classes (1)}
  \begin{itemize}
  \item The default class (\code{SCHED_OTHER}),
    in which threads are started by default,
    is a {\em time-sharing} class
    \begin{itemize}
    \item All threads, regardless of their priority, get some CPU time
    \item The proportion of CPU time they get is dynamic and affected
      by the {\em nice} value, which ranges from -20 (highest) to 19
      (lowest). Can be set using the \code{nice} or \code{renice} commands
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Scheduling classes (2)}
  \begin{itemize}
  \item The real-time classes \ksym{SCHED_FIFO}, \ksym{SCHED_RR} and
         \ksym{SCHED_DEADLINE}
    \begin{itemize}
    \item RT Priorities ranging from 0 (lowest) to 99 (highest)
    \item The highest RT priority thread gets all the CPU time, until it
      blocks.
    \item With \ksym{SCHED_FIFO}, {\em First In, First Out}, each additional
      threads with the same RT priority has to wait for the first ones to block.
    \item In \ksym{SCHED_RR}, {\em Round-Robin} scheduling between the
      threads with the same RT priority. All must block before
      lower priority threads get CPU time.
    \item In \ksym{SCHED_DEADLINE}: guarantees that an RT task
      will be given an exact amount of cpu time every period.
    \end{itemize}
  \end{itemize}
  See \url{https://man7.org/linux/man-pages/man7/sched.7.html} for
  details.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using scheduling classes (1)}
  \begin{itemize}
  \item An existing program can be started in a specific scheduling
    class with a specific priority using the \code{chrt} command line tool
    \begin{itemize}
    \item Example: \code{chrt -f 99 ./myprog} \\
        \code{-f}: \ksym{SCHED_FIFO}\\
	\code{-r}: \ksym{SCHED_RR}\\
	\code{-d}: \ksym{SCHED_DEADLINE}
    \end{itemize}
  \item The \code{sched_setscheduler()} API can be used to change the scheduling class
    and priority of a threads
    \begin{block}{}
\begin{verbatim}
int sched_setscheduler(pid_t pid, int policy,
                const struct sched_param *param);
\end{verbatim}
    \end{block}{}
    \begin{itemize}
    \item \code{policy} can be \code{SCHED_OTHER}, \ksym{SCHED_FIFO},
      \ksym{SCHED_RR}, \ksym{SCHED_DEADLINE}, etc. (others exist).
    \item \code{param} is a structure containing the priority
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using scheduling classes (2)}
  \begin{itemize}
  \item The priority can be set on a per-thread basis when a thread is
    created
    \begin{block}{}
\footnotesize
\begin{verbatim}
struct sched_param parm;
pthread_attr_t attr;

pthread_attr_init(&attr);
pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
parm.sched_priority = 42;
pthread_attr_setschedparam(&attr, &parm);
\end{verbatim}
\normalsize
    \end{block}
  \item Then the thread can be created using \code{pthread_create()},
    passing the \code{attr} structure.
  \item Several other attributes can be defined this way: stack size,
    etc.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Memory locking}
  \begin{itemize}
  \item In order to solve the non-determinism introduced by virtual
    memory, memory can be locked
    \begin{itemize}
    \item Guarantee that the system will keep it allocated
    \item Guarantee that the system has pre-loaded everything into
      memory
    \end{itemize}
  \item \code{mlockall(MCL_CURRENT | MCL_FUTURE);}
    \begin{itemize}
    \item Locks all the memory of the current address space, for
      currently mapped pages and pages mapped in the future
    \end{itemize}
  \item Other, less useful parts of the API: \code{munlockall}, \code{mlock},
    \code{munlock}.
  \item Watch out for non-currently mapped pages
    \begin{itemize}
    \item Stack pages
    \item Dynamically-allocated memory
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutexes}
  \begin{itemize}
  \item Allows mutual exclusion between two threads in the same
    address space
  \item Initialization/destruction
    \begin{block}{}
\footnotesize
\begin{verbatim}
pthread_mutex_init(pthread_mutex_t *mutex,
                   const pthread_mutexattr_t *mutexattr);
pthread_mutex_destroy(pthread_mutex_t *mutex);
\end{verbatim}
\normalsize
    \end{block}
  \item Lock/unlock
    \begin{block}{}
\footnotesize
\begin{verbatim}
pthread_mutex_lock(pthread_mutex_t *mutex);
pthread_mutex_unlock(pthread_mutex_t *mutex);
\end{verbatim}
\normalsize
    \end{block}
  \item Priority inheritance must be activated explicitly
    \begin{block}{}
\footnotesize
\begin{verbatim}
pthread_mutexattr_t attr;
pthread_mutexattr_init (&attr);
pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
\end{verbatim}
\normalsize
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Timers}
  \small
  \begin{itemize}
  \item Timer creation
    \begin{block}{}
\footnotesize
\begin{verbatim}
timer_create(clockid_t clockid, struct sigevent *evp,
             timer_t *timerid);
\end{verbatim}
\small
    \end{block}
    \begin{itemize}
    \item \code{clockid} is usually
      \code{CLOCK_MONOTONIC}. \code{sigevent} defines what happens
      upon timer expiration: send a signal or start a function in a
      new thread. \code{timerid} is the returned timer identifier.
    \end{itemize}
  \item Configure the timer for expiration at a given time
    \begin{block}{}
\footnotesize
\begin{verbatim}
timer_settime(timer_t timerid, int flags,
              struct itimerspec *newvalue,
              struct itimerspec *oldvalue);
\end{verbatim}
\small
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Timers (2)}
  \begin{itemize}
  \item Delete a timer
    \begin{block}{}
\footnotesize
\begin{verbatim}
timer_delete(timer_t timerid)
\end{verbatim}
\small
    \end{block}
  \item Get the resolution of a clock, \code{clock_getres}
  \item Other functions: \code{timer_getoverrun()}, \code{timer_gettime()}
  \item You can also directly use \code{nanosleep()} or
        \code{clock_nanosleep()} to transparently setup timers for
        specified amounts of time.
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Signals}
  \begin{itemize}
  \item Signals are asynchronous notification mechanisms
  \item Notification occurs either
    \begin{itemize}
    \item By the call of a signal handler. Be careful with the limitations of signal
      handlers!
    \item By being unblocked from the \code{sigwait()},
      \code{sigtimedwait()} or \code{sigwaitinfo()} functions. Usually
      better.
    \end{itemize}
  \item Signal behavior can be configured using \code{sigaction()}
  \item The mask of blocked signals can be changed with
    \code{pthread_sigmask()}
  \item Delivery of a signal using \code{pthread_kill()} or
    \code{tgkill()}
  \item All signals between \code{SIGRTMIN} and \code{SIGRTMAX}, 32
    signals under Linux.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Inter-process communication}
  \begin{itemize}
  \item {\bf Semaphores}
    \begin{itemize}
    \item Usable between different processes using named semaphores
    \item \code{sem_open()}, \code{sem_close()}, \code{sem_unlink()},
      \code{sem_init()}, \code{sem_destroy()}, \code{sem_wait()},
      \code{sem_post()}, etc.
    \end{itemize}
  \item {\bf Message queues}
    \begin{itemize}
    \item Allows processes to exchange data in the form of messages.
    \item \code{mq_open()}, \code{mq_close()}, \code{mq_unlink()},
      \code{mq_send()}, \code{mq_receive()}, etc.
    \end{itemize}
  \item {\bf Shared memory}
    \begin{itemize}
    \item Allows processes to communicate by sharing a segment of
      memory
    \item \code{shm_open()}, \code{ftruncate()}, \code{mmap()},
      \code{munmap()}, \code{close()}, \code{shm_unlink()}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Debugging latencies in PREEMPT\_RT}

\begin{frame}
  \frametitle{ftrace - Kernel function tracer}

  Infrastructure that can be used for debugging or analyzing latencies
  and performance issues in the kernel.

  \begin{itemize}
  \item Very well documented in \kdochtml{trace/ftrace}
  \item Negligible overhead when tracing is not enabled at run-time.
  \item Can be used to trace any kernel function!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Using ftrace}
  \begin{itemize}
  \item Tracing information available through the \code{tracefs} virtual fs
  \item Mount this filesystem as follows:\\
    \code{mount -t tracefs nodev /sys/kernel/tracing}
  \item Check available tracers in
    \code{/sys/kernel/tracing/available_tracers}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scheduling latency tracer}
  \fontsize{9}{9}\selectfont
  \kconfig{CONFIG_SCHED_TRACER} ({\em Kernel Hacking} section)
  \begin{itemize}
  \item Maximum recorded time between waking up a top priority task
    and its scheduling on a CPU, expressed in us.
  \item Check that \code{wakeup} is listed in
    \code{/sys/kernel/tracing/available_tracers}
  \item To select, reset and enable this tracer:
    \begin{block}{}
\begin{verbatim}
echo wakeup > /sys/kernel/tracing/current_tracer
echo 0 > /sys/kernel/tracing/tracing_max_latency
echo 1 > /sys/kernel/tracing/tracing_enabled
\end{verbatim}
    \end{block}
  \item Let your system run, in particular real-time tasks.\\
    Dummy example: \code{chrt -f 5 sleep 1}
  \item Disable tracing:\\
    \begin{block}{}
\begin{verbatim}
echo 0 > /sys/kernel/tracing/tracing_enabled
\end{verbatim}
    \end{block}{}
  \item Read the maximum recorded latency and the corresponding trace:\\
    \begin{block}{}
\begin{verbatim}
cat /sys/kernel/tracing/tracing_max_latency
\end{verbatim}
    \end{block}{}
  \end{itemize}
\end{frame}

\subsection{Real-time extensions to the Linux kernel}

\begin{frame}
  \frametitle{Linux real-time extensions}
  \begin{columns}
    \column{0.5\textwidth}
    Three generations
    \begin{itemize}
    \item RTLinux
    \item RTAI
    \item Xenomai
    \end{itemize}
    \column{0.5\textwidth}
    A common principle
    \begin{itemize}
    \item Add an extra layer between the hardware and the Linux kernel, to manage
      real-time tasks separately.
    \end{itemize}
  \end{columns}
  \begin{center}
    \includegraphics[height=0.4\textheight]{slides/sysdev-realtime/real-time-extensions-architecture.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{RTLinux}
  First real-time extension for Linux, created by Victor Yodaiken.
  \begin{itemize}
  \item However, the author filed a software patent covering the
    addition of real-time support to general operating systems as
    implemented in RTLinux!
  \item Its Open Patent License drew many developers away and
    frightened users.  Community projects like RTAI and Xenomai now
    attract most developers and users.
  \item February, 2007: RTLinux rights sold to Wind River. Today,
    no longer advertised by Wind River.
  \item Project completely dead.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{RTAI}
  \url{https://www.rtai.org/} - {\bf Real-Time Application Interface for Linux}
  \begin{itemize}
  \item Created in 1999, by Prof. Paolo Mantegazza (long time
    contributor to RTLinux), Dipartimento di Ingegneria Aerospaziale
    Politecnico di Milano (DIAPM).
  \item Community project. Significant user base. Attracted
    contributors frustrated by the RTLinux legal issues.
  \item Only really actively maintained on x86
  \item May offer slightly better latencies than Xenomai, at the
    expense of a less maintainable and less portable code base
  \item Since RTAI is not really maintained on ARM and other embedded
    architectures, our presentation is focused on Xenomai.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Xenomai project}
  \begin{columns}[T]
    \column{0.8\textwidth}
    \url{https://www.xenomai.org/}
    \begin{itemize}
    \item Started in 2001, as an extension to RTAI, to emulate
	  traditional RTOS APIs.
    \item Initial goals: facilitate the porting of programs to GNU /
	  Linux.
    \item Skins mimicking the APIs of the VxWorks and pSOS traditional
	  real-time operating systems, as well as the POSIX API, and offering
	  a {\em native} API too.
    \item Offers two solutions:
      \begin{itemize}
	 \item {\em Cobalt}: (like {\bf Co}-kernel), using
	       a micro-kernel dedicated to running real-time tasks.
	       This will never be merged in the mainline kernel.
	 \item {\em Mercury}: (like {\bf Mer}ge), based on the mainline
	       kernel with PREEMPT\_RT.
      \end{itemize}
    \end{itemize}
    \column{0.2\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-realtime/xenomai.png}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Xenomai Cobalt architecture}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/sysdev-realtime/xenomai-architecture.pdf}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Xenomai user space real-time support}
  \begin{itemize}
  \item Supported architectures are the ones supported by the {\em
    ipipe} patch: arm, arm64, blackfin, powerpc, x86
  \item Two modes are defined for a thread
    \begin{itemize}
    \item the primary mode, where the thread is handled by the Xenomai
      scheduler
    \item the secondary mode, when it is handled by the Linux scheduler.
    \end{itemize}
  \item Thanks to the services of the Adeos I-pipe service, Xenomai
    system calls are defined.
    \begin{itemize}
    \item A thread migrates from secondary mode to primary mode when
      such a system call is issued
    \item It migrates from primary mode to secondary mode when a Linux
      system call is issued, or to handle gracefully exceptional
      events such as exceptions or Linux signals.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Life of a Xenomai application}
  \begin{itemize}
  \item Xenomai applications are started like normal Linux processes,
    they are initially handled by the Linux scheduler and have access
    to all Linux services
  \item After their initialization, they declare themselves as
    real-time applications, which migrates them to primary mode. In
    this mode:
    \begin{itemize}
    \item They are scheduled directly by the Xenomai scheduler, so
      they have the real-time properties offered by Xenomai
    \item They don't have access to any Linux service, otherwise they
      get migrated back to secondary mode and lose all real-time
      properties
    \item They can only use device drivers that are implemented in
      Xenomai, not the ones of the Linux kernel
    \end{itemize}
  \item Need to implement device drivers in Xenomai, and to split
    real-time and non real-time parts of your applications.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Real Time Driver Model (RTDM)}
  \begin{itemize}
  \item An approach to unify the interfaces for developing device
    drivers and associated applications under real-time Linux
    \begin{itemize}
    \item An API very similar to the native Linux kernel driver API
    \end{itemize}
  \item Allows to develop in kernel space:
    \begin{itemize}
    \item Character-style device drivers
    \item Network-style device drivers
    \end{itemize}
  \item Current notable RTDM based drivers:
    \begin{itemize}
    \item Serial port controllers;
    \item RTnet UDP/IP stack;
    \item RT socket CAN, drivers for CAN controllers;
    \item Analogy, fork of the Comedi project, drivers for acquisition cards.
    \end{itemize}
  \end{itemize}
  \url{https://xenomai.org/documentation/xenomai-3/html/xeno3prm/group__rtdm.html}
\end{frame}

\subsection{Setting up Xenomai}

\begin{frame}[fragile]
  \frametitle{How to build the Xenomai kernel (Cobalt)}
  \begin{itemize}
  \item Download Xenomai sources at
    \url{https://xenomai.org/downloads/xenomai/stable/latest/}
  \item Download the latest {\bf i-pipe} patch for your architecture:\\
    \url{https://xenomai.org/downloads/ipipe/}
  \item Download the corresponding kernel.org version
  \item Xenomai offers a script to patch your kernel. Example (arm):
\begin{verbatim}
./scripts/prepare-kernel.sh  \
    --linux=../linux-4.19.124 \
    --ipipe=../ipipe-core-4.19.124-cip27-arm-09.patch
    --arch=arm \
\end{verbatim}
  \item Run the kernel configuration menu.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linux options for Xenomai configuration}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/sysdev-realtime/xenomai-kernel-config.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{How to build Xenomai user space}
  \begin{itemize}
  \item User space libraries are compiled using the traditional autotools
    \begin{itemize}
    \item \code{./configure --host=arm-linux && make && make DESTDIR=/your/rootfs/ install}
    \end{itemize}
  \item Xenomai installs a {\em xeno-config} script, which helps you
    compile your own programs against the Xenomai libraries.
  \item See Xenomai's \code{examples} directory.
  \item Installation details may be found at
    \url{http://xenomai.org/installing-xenomai-3-x/}
  \item Build systems such as Buildroot can compile the Xenomai user
    space for you.
  \end{itemize}
\end{frame}

\subsection{Developing applications on Xenomai}

\begin{frame}[fragile]
  \frametitle{The POSIX skin}
  \begin{itemize}
  \item The POSIX skin allows to recompile without changes a
    traditional POSIX application so that instead of using Linux
    real-time services, it uses Xenomai services
    \begin{itemize}
    \item {\small
      \url{https://www.xenomai.org/index.php/Porting_POSIX_applications_to_Xenomai}}
    \item Clocks and timers, condition variables, message queues,
      mutexes, semaphores, shared memory, signals, thread management
    \item Good for existing code or programmers familiar with the
      POSIX API
    \end{itemize}
  \item Of course, if the application uses any Linux service that
    isn't available in Xenomai, it will switch back to secondary mode
  \item To link an application against the POSIX skin
  \end{itemize}
  \begin{block}{}
\small
\begin{verbatim}
CFL=`xeno-config --skin=posix --cflags`
LDF=`xeno-config --skin=posix --ldflags`
ARCH-gcc $CFL -o rttest rttest.c $LDF
\end{verbatim}
\normalsize
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Communication with a normal task}
  \begin{itemize}
  \item If a Xenomai real-time application using the POSIX skin wishes
    to communicate with a separate non-real-time application, it must
    use the rtipc mechanism
  \item In the Xenomai application, create an \code{IPCPROTO_XDDP}
    socket
    \begin{block}{}
\footnotesize
\begin{verbatim}
socket(AF_RTIPC, SOCK_DGRAM, IPCPROTO_XDDP);
setsockopt(s, SOL_RTIPC, XDDP_SETLOCALPOOL,
           &poolsz, sizeof(poolsz));
memset(&saddr, 0, sizeof(saddr));
saddr.sipc_family = AF_RTIPC;
saddr.sipc_port = PORTX;
ret = bind(s, (struct sockaddr *)&saddr, sizeof(saddr));
\end{verbatim}
\normalsize
    \end{block}
    \begin{itemize}
    \item And then the normal socket API \code{sendto()} / \code{recvfrom()}
    \end{itemize}
  \item In the Linux application
    \begin{itemize}
    \item Open \code{/dev/rtpPORTX}, where \code{PORTX} is the XDDP
      port
    \item Use \code{read()} and \code{write()}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alchemy: the native API}
  Xenomai proposes its own API for developing real-time tasks
  \begin{itemize}
  \item {\small
    \url{https://xenomai.org/documentation/xenomai-3/html/xeno3prm/group__alchemy.html}}
  \item Xenomai developers find it a more coherent and more flexible API
    than the POSIX API, and easier to learn and understand.
  \item However, beware that programming with the POSIX API is much
    more portable (ability to use regular Linux, Linux with PREEMPT\_RT, Xenomai
    and other POSIX operating systems).
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Benchmarks: mainline vs PREEMPT\_RT vs Xenomai }
  \code{cyclictest} results on BeagleBone Black (ARM), with different
  kernel setups. Wake-up time measured in $\mu$s.
  \scriptsize
  \begin{table}[h]
  \caption{Idle CPU}
  \begin{tabular}{| l || r | r | r |}
  \hline
  & min & avg & max \\
  \hline
  Mainline Linux & 39 & 43 & 1046 \\
  \hline
  PREEMPT\_RT & 16 & 21 & 52 \\
  \hline
  Xenomai 2 & 8 & 9 & 41 \\
  \hline
  Xenomai 3 & 7 & 7 & 35 \\
  \hline
  \end{tabular}
  \end{table}
  \begin{table}[h]
  \caption{Stressed CPU}
  \begin{tabular}{| l || r | r | r |}
  \hline
  & min & avg & max \\
  \hline
  Mainline Linux & 39 & 52 & 1097 \\
  \hline
  PREEMPT\_RT & 18 & 25 & 62 \\
  \hline
  Xenomai 2 & 8 & 19 & 45 \\
  \hline
  Xenomai 3 & 6 & 16 & 37 \\
  \hline
  \end{tabular}
  \end{table}
  \url{http://wiki.csie.ncku.edu.tw/embedded/xenomai/rtlws_paper.pdf}
\end{frame}

\begin{frame}
  \frametitle{Organizations}
  \begin{itemize}
  \item \url{https://wiki.linuxfoundation.org/realtime/start}\\
    The Linux Foundation, now funding work on PREEMPT\_RT
  \item \url{https://www.osadl.org}\\
    Open Source Automation Development Lab (OSADL)\\
    Targets machine and plant control systems. Most member companies
    are German (Thomas Gleixner is on board). Supports the use of
    PREEMPT\_RT and Xenomai and contributes to these projects. Shares
    useful documentation and resources.

    They also organize a yearly Real Time Linux Workshop.
  \end{itemize}
\end{frame}

\setuplabframe
{Real-time - Scheduling latency}
{
  \begin{itemize}
  \item Check clock accuracy.
  \item Start processes with real-time priority.
  \item Build a real-time application against the standard POSIX
        real-time API, and against Xenomai’s POSIX skin
  \item Compare scheduling latency on your system, between a standard
        kernel, a kernel with PREEMPT\_RT and a kernel with Xenomai.
  \end{itemize}
}

