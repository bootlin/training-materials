\subsection{Render Accelerators}

\begin{frame}{Digital Signal Processors}
  \begin{itemize}
  \item Digital Signal Processors (DSPs) allow programmable image signal processing\\
    \textit{can also be used for implementing 2D rendering primitives}
  \item Using a dedicated Instruction Set Architectures (ISA)
  \item Arithmetic implementations are either:
    \begin{itemize}
    \item \textbf{fixed-point}: simple hardware implementation, fixed range (usually 16.16)\\
      \textit{16 bits for the integer part and 16 bits for the decimal part}
    \item \textbf{floating-point}: complex implementations, trade-off between range and precision
    \end{itemize}
  \item Usually more power-efficient than general-purpose CPUs
  \item Depending on the DSP, the software can be:
    \begin{itemize}
    \item A \textbf{standalone firmware}, usually developed from vendor libraries (C/C++/ASM)
    \item A \textbf{real-time operating system} (RTOS) application (C/C++/...)
    \end{itemize}
  \item Can be used standalone in a video pipeline or to offload a CPU
  \item Modern DSPs can be multi-core and feature various I/O controllers
  \end{itemize}
\end{frame}

\begin{frame}{Dedicated hardware accelerators}
  \begin{itemize}
  \item Fixed-function hardware can be used for accelerating specific operations
  \begin{itemize}
    \item Implemented as hardware circuits in Systems on a Chip (SoCs) or DSPs
    \item Implemented as logic configuration bitstream in FPGAs
  \end{itemize}
  \item Implement a configurable fixed pipeline for image operations
  \item Accessed and configured through specific registers exposed via a bus
    \begin{itemize}
    \item Global configuration registers to build the pipeline between blocks
    \item Configuration registers for each block
    \item Kick and status registers
    \end{itemize}
  \item Usually very power-efficient and very fast
  \end{itemize}
\end{frame}

\begin{frame}{Dedicated hardware accelerators (illustrated)}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{slides/graphics-hardware-render/g2d-block.png}\\
    \textit{An example hardware pipeline for a 2D graphics block}\\
  \end{center}
\end{frame}

\begin{frame}{Graphics Processing Unit}
  \begin{itemize}
  \item Graphics Processing Units (GPUs) are \textbf{3D rendering hardware} implementations\\
    \textit{the term no longer designates all graphics-processing hardware}
  \item Operate on 3D graphics primitives: \textbf{points (vertices), lines and triangles}
  \item Generate a 2D view (viewport) from a given perspective
    \begin{itemize}
      \item Objects are formed of interconnected triangles
      \item A color can be applied to each vertex and interpolated
      \item Textures can be applied to objects with texture element to vertex mapping
      \item Lighting is applied from various sources
    \end{itemize}
  \item Expected to render at \textbf{display scanout rate} (pseudo real-time)
    \begin{itemize}
    \item Usually not photo-realistic methods as ray tracing or photon mapping
    \item Extremely efficient compared to any general-purpose CPU
    \end{itemize}
  \item GPUs are also used for general-purpose computing with GPGPU
  \end{itemize}
\end{frame}

\begin{frame}{Graphics Processing Unit architectures}
  \begin{itemize}
  \item GPUs implement a pipeline of hacks accumulated since the 1970s
  \item GPU hardware architectures evolved over time:
    \begin{itemize}
    \item From \textbf{fixed-function} configurable hardware block pipelines
    \item To pipelines with both fixed blocks and specialized \textbf{programmable} processing units
    \end{itemize}
  \item Shaders are programs that run at different steps of the pipeline:
    \begin{itemize}
    \item \textbf{vertex shaders}: define the position, texture coordinates and lighting of each vertex
    \item \textbf{geometry shaders}: generate new primitives from the provided ones
    \item \textbf{tesselation shaders}: perform vertex sub-division (e.g. Catmull-Clark)
    \item \textbf{fragment/pixel shaders}: perform rasterization for each output pixel
    \end{itemize}
  \item Scenes can be rendered with multiples passes and multiple shaders
  \end{itemize}
\end{frame}

\begin{frame}{Graphics Processing Unit architectures (illustrated)}
  \begin{center}
  \includegraphics[width=0.5\textwidth]{slides/graphics-hardware-render/gpu-pipeline.png}\\
  \textit{\small A programmable GPU pipeline}
  \end{center}
\end{frame}

\begin{frame}{Graphics Processing Unit techniques}
  \begin{itemize}
  \item GPUs are optimized for \textbf{performance} and \textbf{good-looking results}
  \item \textbf{Texture sampling} can easily cause aliasing (at a distance)
    \begin{itemize}
    \item \textbf{Bilinear and trilinear filtering} is often used
    \item \textbf{Anisotropic filtering} provides best visual results
    \item \textbf{Mip-maps} provide the same texture at different sizes
    \item \textbf{Multi-Sample Anti-Aliasing} (MSAA) averages colors from multiple points
    \end{itemize}
  \item \textbf{Texture compression} reduces memory pressure (e.g. S3TC, ASTC)
  \item \textbf{Normal mapping/bump maps} provide increased details with low vertex count\\
    \textit{affects light path calculation}
  \item Avoiding \textbf{useless rendering} operations:
    \begin{itemize}
    \item Occluded surfaces are not rendered (visible surface determination)
    \item Using a \textbf{depth/z-buffer} to keep track of the z-order for each output pixel
    \item Culling for early vertex removal: back-face, view frustum, z-buffer
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Graphics Processing Unit techniques (illustrated)}
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-hardware-render/anisotropic-filtering.png}\\
    \textit{Comparison of tri-linear and anisotropic anti-aliasing filtering}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[height=7em]{slides/graphics-hardware-render/mip-map.jpg}\\
    \textit{A mip-mapped texture representation}
  \end{minipage}
\end{frame}

\begin{frame}{Graphics Processing Unit internals}
  \begin{itemize}
  \item A \textbf{command stream} is parsed and used to configure the pipeline
  \item Shader cores have highly-specialized ISAs adapted for geometry:
  \begin{minipage}[b]{0.45\textwidth}
    \begin{itemize}
    \item Vector operations, SIMD
    \item Trigonometric operations
    \end{itemize}
  \end{minipage}
  \begin{minipage}[b]{0.45\textwidth}
    \begin{itemize}
    \item Interpolation operations
    \item Usually few conditionals
    \end{itemize}
  \end{minipage}
  \item Texture access is provided by a \textbf{Texture Mapping Unit} (TMU)
    \begin{itemize}
    \item Caching is used to reduce memory pressure
    \end{itemize}
  \item Modern GPUs sometimes have a \textbf{unified shader core}\\
    \textit{allows efficient hardware resources usage, with complex scheduling}
  \item Shading cores are \textbf{duplicated} and work in parallel (especially rasterization)
  \item Some architectures implement tiled processing:
    \begin{itemize}
    \item Output is divided in tiles (clipping areas) and distributed to cores
    \item Each rasterized tile is written to the output framebuffer separately
    \end{itemize}
  \end{itemize}
\end{frame}
