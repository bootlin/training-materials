\section{Base Theory and Concepts About Graphics}

\subsection{Image and Color Representation}

\begin{frame}{Light, pixels and pictures}
  \begin{itemize}
  \item Pictures are {\bf representations of light emissions}
  \item Analog representations are spatially {\bf continuous}:
    \begin{itemize}
    \item with an {\bf infinite} number of elements
    \item example : photosensitive paper
    \end{itemize}
  \item Digital representations are spatially {\bf quantified}:
    \begin{itemize}
    \item with a {\bf finite} number of elements
    \item example : discrete LED-based display
    \end{itemize}
  \item Producing a digital representation is called \textbf{quantization}
  \item Quantization requires a {\bf base element unit} or quantum
  \item This quantum is called picture element or {\bf pixel}
  \item Quantization is also called \textbf{sampling} in this context
  \end{itemize}
\end{frame}

\begin{frame}{Light, pixels and pictures}
  \begin{itemize}
  \item Quantified pixels have a \textbf{spatial density} or spatial resolution:\\
  \textit{How many pixels are found in \(n\) inches?}
  \item The usual pixel resolution unit is the \textbf{dot per inch} (DPI)
  \item Vertical and horizontal spatial densities are usually not distinguished
  \end{itemize}

  \begin{center}
  From single pixels to depicting a subject:
  \end{center}

  \begin{itemize}
  \item Pictures are bi-dimensional ordered ensembles of pixels (also called \textbf{frames})
  \item As such, pixels are disposed along two axis and each have a \textbf{position}:\\
   \textit{horizontal (\(x\)) and vertical (\(y\)) positions}
  \item Pictures have \textbf{dimensions}, expressed as a number of pixels:\\
   \textit{horizontal (\(width\)) and vertical (\(height\)) dimensions}
  \end{itemize}

\end{frame}

\begin{frame}{Light, pixels and pictures (illustrated)}
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/first-photo.jpg}
    \textit{\small View from the Window at Le Gras picture}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/dot-matrix-display.jpg}
    \textit{\small A monochrome dot-matrix display}
  \end{minipage}

  \vspace{1em}

  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{Analog representation},\\ on a metal plate
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{Digital representation},\\ on a LED display
  \end{minipage}
\end{frame}

\begin{frame}{Light representation, color quantization}
  \begin{minipage}[c]{0.75\textwidth}
    \begin{itemize}
    \item Light itself must be quantized in digital representations\\
    \textit{distinct from and unrelated to spatial quantization}
    \item Translating light information (colors) to numbers
    \item The translation referential is called \textbf{colorspace}
    \item The translated color has coordinates in the colorspace\\
    \textit{e.g. 3 for a human-eye-alike referential: red, green, blue}
    \item The color coordinates are quantized with:
      \begin{itemize}
      \item A given \textbf{resolution}:
      \textit{the smallest possible color difference}
      \item A given \textbf{range}:
      \textit{the span of representable colors}
      \end{itemize}
    \item Both aspects of color quantization depend on:
      \begin{itemize}
      \item The colorspace taken as referential
      \item The color depth or number of \textbf{bits per pixel} (bpp)
      \item Implementation choices
      \end{itemize}
    \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[c]{0.225\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/rgb-cube.pdf}
  \end{minipage}
\end{frame}

\begin{frame}{Light representation, color quantization (illustrated)}
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/pair-of-merops.jpg}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/pair-of-merops-16-colors.jpg}
  \end{minipage}

  \begin{center}
     \textit{\small A pair of Merops feeding}
  \end{center}

  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{16 million colors (24 bits per pixel)}
    \begin{itemize}
    \item high color resolution
    \item high color range
    \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{16 colors (4 bits per pixel)}
    \begin{itemize}
    \item low color resolution
    \item low color range
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{Light representation, color quantization (illustrated)}
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/pair-of-merops.jpg}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/pair-of-merops-16-colors-range.jpg}
  \end{minipage}

  \begin{center}
     \textit{\small A pair of Merops feeding}
  \end{center}

  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{16 million colors (24 bits per pixel)}
    \begin{itemize}
    \item high color resolution
    \item high color range
    \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \textbf{16 colors (4 bits per pixel)}
    \begin{itemize}
    \item lower color resolution
    \item high color range
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{Level of detail of quantized pictures}
  Depends on a number of factors, including:
  \begin{itemize}
  \item Spatial density (pixel resolution)
  \item Quantized dimensions (picture width and height)
  \item Colorspace limits (chromaticity diagram)
  \item Color depth (number of bits per pixel)
  \item Color resolution and range trade-off
  \end{itemize}~

  Generally speaking:
  \begin{itemize}
  \item Many factors are involved
  \item The major bottleneck is not always obvious
  \item Implementation choices do matter
  \end{itemize}
\end{frame}

\begin{frame}{Colorspaces and channels}
  \begin{minipage}[b]{0.7\textwidth}
    \begin{itemize}
    \item Each component of a colorspace is called a \textbf{channel}
    \item Examples for usual types of colorspaces:
      \begin{itemize}
      \item RGB, with 3 channels:\\ \textbf{R} (red) / \textbf{G} (green) / \textbf{B} (blue)
      \item HSV, with 3 channels:\\ \textbf{H} (hue) / \textbf{S} (saturation) / \textbf{V} (value)
      \item YUV or Y/Cb/Cr, with 3 channels:\\ \textbf{Y} (luminance) / \textbf{U or Cb} / \textbf{V or Cr} (chrominance)
      \end{itemize}
    \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.25\textwidth}
    \centering
    \includegraphics[width=\textwidth]{slides/graphics-introduction/hsv-diagram.pdf}\\
    \vspace{-1em}
    \textit{\small HSV diagram}
    \vspace{0.25em}
  \end{minipage}
  \begin{itemize}
  \item An additional channel can exist for transparency: the \textbf{alpha channel}\\
  \textit{mostly relevant for composition, not for final display}
  \item Color coordinates can be \textbf{converted} from one colorspace to another (CSC)\\
  \textit{using translation formulas and associated constants}
  \end{itemize}
\end{frame}

\begin{frame}{Colorspaces and channels (illustrated with YUV)}
  \begin{minipage}[t]{0.25\textwidth}
    \centering
    \includegraphics[height=6em]{slides/graphics-introduction/barn.jpg}\\
    \textit{\small Original picture}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.7\textwidth}
    \centering
    \includegraphics[height=6em]{slides/graphics-introduction/barn-yuv.jpg}\\
    \textit{\small Decomposition in Y, U and V channels}
  \end{minipage}

  \vspace{1em}

  \begin{minipage}[t]{0.4\textwidth}
    \small
    \begin{equation*}
    \begin{cases}
    R = Y + 1.140 \times V\\
    G = Y - 0.395 \times U - 0.581 \times V\\
    B = Y + 2.032 \times U
    \end{cases}
    \end{equation*}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.55\textwidth}
    \small
    \begin{equation*}
    \begin{cases}
    Y = + 0.299 \times R + 0.587 \times G + 0.114 \times B\\
    U = - 0.147 \times R - 0.289 \times G + 0.436 \times B\\
    V = + 0.615 \times R - 0.515 \times G - 0.100 \times B
    \end{cases}
    \end{equation*}
  \end{minipage}

  \begin{center}
     \textit{\small Translation between BT.609 YUV and sRGB colorspaces}
  \end{center}
\end{frame}

\begin{frame}{Frame size and chroma sub-sampling}
  \begin{itemize}
  \item Digital pictures easily take up a lot of space (moreso for videos)
  \item The minimal size for a picture depends on:
    \begin{itemize}
    \item Dimensions (\(width\) and \(height\))
    \item Color (and alpha) depth or bits per pixel (\(bpp\))
    \item Roughly: \(width \times height \times bpp \div 8~bytes\)
    \item For 12 Mpixels with 16 Mcolors and alpha: \(4000 \times 3000 \times 32 \div 8 = 45.8 MiB\)
    \end{itemize}
  \item The human visual system has specificities:
    \begin{itemize}
    \item High sensitivity to \textbf{luminosity} (luminance)
    \item Low sensibility to \textbf{colors} (chrominance)
    \end{itemize}
  \item YUV colorspaces offer the relevant channel separation
  \item Sub-sampling can be applied to the chrominance channel\\
  \textit{less data (and precision) on colors to reduce size}
  \end{itemize}
\end{frame}

\begin{frame}{Frame size and chroma sub-sampling}
  \begin{itemize}
  \item Chrominance samples are used for multiple luminance samples
  \item With specific vertical and horizontal ratios (usually integer)
  \item Usually summarized using a three-part ratio: \(J:a:b\)
  \end{itemize}

  \begin{center}
  \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/yuv-sub-sampling.pdf}

  YUV 4:2:0 usual example:\\
  {\small\(bpp_Y = 8,~bpp_U = 8 / 2 = 4,~bpp_V = 8 / 2 = 4 ~\Rightarrow~ bpp = 16~bits/pixel\)}
  \end{center}
\end{frame}

\begin{frame}{Pixel data distribution in memory}
  \begin{itemize}
  \item Pixel data can be \textbf{distributed} in different ways in memory
  \item Different ways to aggregate color components in \textbf{data planes} (memory chunks):
    \begin{itemize}
    \item \textbf{Packed}: Components are stored in the same data plane in memory
    \item \textbf{Semi-planar} (YUV): Luma and chroma are stored in distinct data planes
    \item \textbf{Planar}: Each component has its own data plane in memory
    \end{itemize}
  \item When multiple color components are grouped, \textbf{bit order} must be specified:
    \begin{itemize}
    \item Which component comes first in memory?
    \item Affected by endianness when read by hardware!
    \end{itemize}
  \item \textbf{Scan order} must also be specified:
    \begin{itemize}
    \item How to calculate the address for position \((x,y)\) and back?
    \item Raster order (most common) specifies: row-major, left-to-right, top-to-bottom
    \end{itemize}
  \end{itemize}
  \begin{center}
  \includegraphics[height=6em]{slides/graphics-introduction/raster-order.pdf}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Pixel formats, FourCC codes}
  \begin{itemize}
  \item Many meta-data elements are needed to fully describe how a picture is coded
    \begin{itemize}
    \item Some describe \textbf{picture-level attributes} (e.g. dimensions)
    \item Some describe \textbf{pixel-level attributes} (e.g. colorspace, bpp)
    \end{itemize}
  \item Pixel-level attributes are grouped as a \textbf{pixel format} that defines:
    \begin{itemize}
    \item Colorspace in use
    \item Number of bits per channel and per pixel (bpp)
    \item Bit attribution and byte order (endianness)
    \item Per-channel sub-sampling ratios
    \item Pixel data distribution in memory
    \end{itemize}
  \item Often represented as a 4-character code called \textbf{FourCC} {\small(\url{https://fourcc.org/})}\\
  \textit{Not really standardized but widely used in various forms}
  \item Example: \verb,DRM_FORMAT_XRGB8888, is defined with the \verb,XR24, FourCC
  \end{itemize}

\end{frame}

\subsection{Basic Drawing and Processing}

\begin{frame}{Ideas}

* how to draw pixels (XRGB32)
* iterating a frame's pixels (h > w)
* 

\end{frame}

\subsection{Advanced Processing}

\section{Hardware Aspects}

\subsection{Pipeline Components Overview and Generalities}

\begin{frame}{Technological types of graphics hardware implementations}
  \begin{itemize}
  \item Two commonly-used technologies, specific pros/cons:
  \end{itemize}

  \begin{center}
  \small
  \def\arraystretch{1.2}
  \begin{tabular}{l|c|c}
  & \textbf{Fixed-function} & \textbf{Programmable} \\
  \hline
  \textbf{Technology} & Circuit & Software \\
  \textbf{Source form} & HDL & Source code \\
  \textbf{Product form} & Silicon, bitstream & Firmware binaries \\
  \textbf{Implementation medium} & FPGA, ASIC, SoC block & DSP, custom ISA \\
  \textbf{Arithmetic} & Fixed-point & Fixed-point, floating point \\
  \textbf{Clock rate} & Low & High \\
  \textbf{Pixel data access} & Queue (FIFO) & Memory \\
  \textbf{CPU control} & Direct registers & Mailbox \\
  \textbf{Die surface (tendency)} & High & Low \\
  \textbf{Reusability} & Low & High \\
  \hline
  \textbf{Example} & Allwinner SoCs Display Engine & TI TMS340 DSP \\
  \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Graphics memory and buffers}
  \begin{itemize}
  \item Pixel data is stored in memory buffers, called \textbf{framebuffers}
  \item Framebuffers live either on:
    \begin{itemize}
    \item \textbf{System memory}: shared with the rest of the system (e.g. SDRAM or SRAM)
    \item \textbf{Dedicated memory}: only for graphics (e.g. SGRAM)
    \end{itemize}
  \item Framebuffers that can be displayed are called \textbf{scanout framebuffers}\\
  \textit{hardware constraints don't always allow any framebuffer to be scanned out}
  \item CPU access to pixel data in dedicated memory is not always granted or easy!
  \item Graphics hardware \textbf{needs configuration} to interpret framebuffer pixel data\\
    \textit{pixel meta-data is rarely to never stored aside of the pixel data}
  \end{itemize}
\end{frame}

\begin{frame}{I/O with graphics hardware, pipelines}
  \begin{itemize}
  \item Graphics hardware is \textbf{I/O-based} and interacts with pixel data
  \item Pipeline elements have input-output abilities:
    \begin{itemize}
    \item \textbf{Source} components: \textbf{feed pixel data}: \textit{e.g. camera}
    \item \textbf{Sink} components: \textbf{grab pixel data}: \textit{e.g. display}
    \end{itemize}
  \item Some components are \textbf{both a source and a sink}: \textit{e.g. converters}
  \item Graphics components can be chained in \textbf{pipelines}\\
    \textit{Usually from a source-only element to a sink-only element}
  \end{itemize}

  \vspace{-2em}
  \begin{center}
  \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/pipeline-sink-source.pdf}
  \end{center}
\end{frame}

\begin{frame}{Display hardware overview}
  \begin{itemize}
  \item \textbf{Stream pixel data} to a display device, via a display interface
  \item Internal pipeline with \textbf{multiple components}
  \item Generally \textbf{fixed-function} hardware, pipeline sink only
  \item Either \textbf{discrete} (video card) or \textbf{integrated}
  \item Connected to the CPU (and RAM) via a \textbf{high-speed bus}:\\
  \textit{e.g. AXI with ARM, ISA, PCI, AGP, PCI-e with x86}
  \end{itemize}~

  \begin{minipage}[t]{0.45\textwidth}
    \centering
    \includegraphics[height=7em]{slides/graphics-introduction/ati-hercules-1986.png}\\
    \textit{\small A 1986 Hercules discrete video card}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.45\textwidth}
    \centering
    \includegraphics[height=7em]{slides/graphics-introduction/intel-skylake.jpg}\\
    \textit{\small An Intel processor with integrated graphics}
  \end{minipage}
\end{frame}

\begin{frame}{Common components of a display pipeline overview}
  \begin{center}
  \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/display-pipe.pdf}
  \end{center}

  \begin{enumerate}
  \item \textbf{Framebuffers} where the pixel data is stored
  \item \textbf{Planes} that associate a framebuffer with its dimensions and position
  \item \textbf{CRTC} for pixel composition and streaming\\
  \textit{The CRTC terminology comes from the legacy Cathode-Ray Tube Controller}
  \item \textbf{Encoder} for meta-data addition and physical signal conversion
  \item \textbf{Connector} for video signal, display data channel (DDC), hotplug detection
  \item \textbf{Monitor} for decoding and displaying pixels (decoder and panel)
  \end{enumerate}
\end{frame}

\begin{frame}{Render hardware overview}
  \textbf{Rendering} hardware includes a wide range of aspects (usual cases below):
  \begin{itemize}
  \item \textbf{Basic} pixel processing:
  \begin{itemize}
    \item Common operations: pixel format, CSC, dithering, scaling, blitting and blending
    \item Fixed-function hardware, pipeline sink and source
  \end{itemize}
  \item \textbf{Complex} pixel processing:
  \begin{itemize}
    \item Defined by the application: any computable operation
    \item Programmable hardware (DSP), pipeline sink and source
  \end{itemize}
  \item \textbf{2D vector} drawing:
  \begin{itemize}
    \item Rasterisation from equations, parameters and data (e.g. points)
    \item Either fixed-function or programmable hardware (custom), pipeline source
  \end{itemize}
  \item \textbf{3D scene} rendering:
  \begin{itemize}
    \item Rasterisation from programs (shaders) and data (e.g. vertices, lines, triangles textures)
    \item Programmable hardware (GPU), pipeline source
  \end{itemize}
  \item Rendering can \textbf{always fallback} to general-purpose CPU operations
  \end{itemize}
\end{frame}

\begin{frame}{Video hardware overview}
  \textbf{Video-oriented} hardware comes in different forms (usual cases below):

  \begin{itemize}
  \item \textbf{Hardware video decoder} (VPU/video codec decoder)
  \begin{itemize}
    \item Decodes a video from compressed data (bitstream) to pixel frames
    \item Fixed-function hardware, pipeline source
  \end{itemize}
  \item \textbf{Hardware video encoder} (VPU/video codec encoder)
  \begin{itemize}
    \item Encodes a video from pixel frames to compressed data (bitstream)
    \item Fixed-function hardware, pipeline sink
  \end{itemize}
  \item \textbf{Camera sensors, video input, video broadcasting} (DVB)
  \begin{itemize}
    \item Receives/sends data in a given configuration from/to \textit{the outside}
    \item Can be compressed data (bitstream) or raw pixel data
    \item Fixed-function hardware, pipeline source
  \end{itemize}
  \end{itemize}~
\end{frame}

\begin{frame}{Building complex pipelines}

  \begin{itemize}
  \item Display, rendering and video elements are chained from source(s) to sink(s)
  \item On source-sink boundaries:
    \begin{itemize}
    \item Mutually-supported pixel format (or conversion)
    \item Mutually-accessible memory (or copy)
    \end{itemize}
  \item Target frame rate (\(fps\)) gives a time budget for pipeline traversal:
  \( t_0 + t_2 + t_4 + t_5 < fps^{-1},~ t_0 + t_3 < fps^{-1},~ t_1 + t_4 + t_5 < fps^{-1} \)
  \end{itemize}

  \begin{center}
  \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/pipeline-complex.pdf}
  \end{center}

\end{frame}

\subsection{Display Hardware Specifics}

\begin{frame}{Visual display technologies generalities}
  \begin{itemize}
  \item Pixel data is pushed from the display interface to a visible surface\\
  \textit{using a dedicated controller on the display device}
  \item Pixels are split into 3 color cells (R-G-B)
  \item The human eye naturally merges light from the 3 cells
  \item Pixel frames are displayed as (physical) arrays of color cells
  \end{itemize}~

  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=6.5em]{slides/graphics-introduction/pixel-array.jpg}\\
    \textit{\small Pixel color cells on a LCD TN panel}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=6.5em]{slides/graphics-introduction/pixel-array-text.jpg}\\
    \textit{\small A pixel array displaying text}
  \end{minipage}
\end{frame}

\begin{frame}{CRT display technology}
  \begin{itemize}
  \item Color \textbf{cathode-ray tubes} (CRTs), since the 1950s:
    \begin{itemize}
    \item Using electron beams to excite a phosphorescent screen
    \item Beams are guided by magnetic deflection
    \item One beam for each color with increased intensity for increased luminosity
    \item High energy consumption
    \item High contrast, medium response time (\(1-10~\mu s\))
    \item Other issues: monitor size, burn-in (screensavers), remanent magnetic field (degaussing), high voltages and magnetic fields
    \end{itemize}
  \end{itemize}

  \begin{center}
  \includegraphics[height=8em]{slides/graphics-introduction/crt-color.png}
  \end{center}
\end{frame}

\begin{frame}{Plasma display panels technology}
  \begin{itemize}
  \item \textbf{Plasma display panels} (PDPs), since the 1990s-2000s:
    \begin{itemize}
    \item Using gas cells brought to plasma state to strike light-emitting phosphor
    \item Flat array of cells, scales to large surfaces
    \item Medium energy consumption (depends on luminance)
    \item Medium to low contrast, low response time (\(\leq 1~\mu s\))
    \item Other issues: burn-in
    \item Gradually being \textbf{deprecated} in favor of other flat-panel technologies
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{LCD display technology}
  \begin{itemize}
  \item \textbf{Liquid crystal displays} (LCDs) using \textbf{Thin-film-transistors} (TFT):
    \begin{itemize}
    \item Using the electrically-controlled alignment of crystal structures to block light
    \item Does not emit light: needs an always-on backlight source (usually LEDs)
    \item Low energy consumption (depends on backlight)
    \item Medium to low contrast, high response time (\(1-10~ms\))
    \item \textbf{Twisted nematic} (TN): limited color quality and viewing angles, since the 1980s
    \item \textbf{In-plane switching} (IPS): improved color and viewing angles, since the 2000s
    \end{itemize}
  \end{itemize}

  \begin{center}
  \includegraphics[height=6em]{slides/graphics-introduction/lcd-ips-shape.jpg}\\
  \textit{\small Chevron shapes that improve the viewing angle on IPS LCDs}
  \end{center}
\end{frame}

\begin{frame}{OLED display technology}
  \begin{itemize}
  \item \textbf{Organic light-emitting diodes} (OLEDs), since 2010:
    \begin{itemize}
    \item Using organic compounds (carbon-based) to emit light as R-G-B LEDs
    \item Allows flat and flexible surfaces, with a large viewing angle
    \item Low energy consumption
    \item Very high contrast, high response time (\(1-10~\mu s\))
    \item Issues: burn-in, independent cells aging, affected by UV light
    \item Rapidly becoming \textbf{very popular} and used
    \end{itemize}
  \end{itemize}

  \begin{center}
  \includegraphics[height=8em]{slides/graphics-introduction/oled-display.jpg}\\
  \textit{\small A flexible OLED display panel}
  \end{center}
\end{frame}

\begin{frame}{EPD display technology}
  \begin{itemize}
  \item \textbf{Electrophoretic displays} (EPDs), since the 2000s:
    \begin{itemize}
    \item Using black and white electrically-charged particles in ink\\
    \textit{e.g. positive charge for black and negative for black}
    \item Electric fields attract one or the other color with current flow
    \textit{the particles stay in place after they were moved}
    \item Using incident light, does not emit light itself
    \item Very low consumption (only for changes)
    \item Low response time (\(1-10~\mu s\)) and ghosting
    \end{itemize}
  \end{itemize}~

  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=6.5em]{slides/graphics-introduction/e-reader.jpg}\\
    \textit{\small An e-reader with an EPD display}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=6.5em]{slides/graphics-introduction/epd-detail.jpg}\\
    \textit{\small Detail of an EPD display}
  \end{minipage}
\end{frame}

\begin{frame}{CRTs, refreshing and timings}
  \begin{itemize}
  \item CRTs need frequent refreshing or the picture fades out: \textbf{fixed refresh rate}
  \item An electron gun aims for pixels in \textbf{row-major/raster order}
  \begin{center}
  \includegraphics[height=8em]{slides/graphics-introduction/raster-scan.pdf}
  \end{center}
  \item Some \textbf{blank time} is needed to reposition the gun (horizontally and vertically)
  \item As a result, \textbf{specific timings} are needed for the signals to each CRT display
  \item For backwards compatibility with CRTs, \textbf{display timings are still necessary}
  \end{itemize}
\end{frame}

\begin{frame}{Display timings and modes}
  \begin{itemize}
  \item Timings coordinate how a frame is \textbf{transmitted to a display over time}
  \item Various signals are involved, synced to a \textbf{pixel clock} (time base)
  \item Display timings are split in a few stages (horizontal and vertical):
    \begin{enumerate}
    \item Sync pulse (vsync/hsync)
    \item Back porch (vbp/hbp)
    \item Active region (vactive/hactive)
    \item Front porch (vfp/hfp)
    \end{enumerate}
  \item Pixels are transmitted during the \textbf{horizontal active region} only
  \item A \textbf{display mode} groups timings, refresh rate and associated pixel clock rate
  \item Display signals are \textbf{generated by the CRTC}, according to the display mode
  \item Monitors usually support \textbf{multiple modes} (and dimensions)
  \end{itemize}
\end{frame}

\begin{frame}{Display timings and modes (illustrated)}
  \begin{center}
  \includegraphics[width=0.8\textwidth]{slides/graphics-introduction/display-timings.pdf}
  \end{center}

  \begin{itemize}
  \item The unit for horizontal stages is \textbf{one pixel clock period}
  \item The unit for vertical stages is \textbf{one line's duration}
  \end{itemize}
\end{frame}

\begin{frame}{Display timings and modes (panel example)}

  \begin{minipage}[b]{0.35\textwidth}
    \centering
    \vspace{2em}
    \includegraphics[width=\textwidth]{slides/graphics-introduction/timings-table.png}
    \textit{\small AT070TN94 panel datasheet}
    \vfill~
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.6\textwidth}
    \small
    \begin{itemize}
    \item \(hsync = thpw = 20 \in \llbracket 1;40 \rrbracket\)\\
    \(hbp = thb - thpw = 46 - 20 = 26\) (from diagram)\\
    \(hactive = thd = 800\)\\
    \(hfp = thfp = 210 \in \llbracket 16;354 \rrbracket\)\\
    \(htotal = hsync + hbp + hactive + hfp = 1056\)

    \item \(vsync = tvpw = 10 \in \llbracket 1;20 \rrbracket\)\\
    \(vbp = tvb - tvpw = 23 - 10 = 13\) (from diagram)\\
    \(vactive = tvd = 480\)\\
    \(vfp = tvfp = 22 \in \llbracket 7;147 \rrbracket\)\\
    \(vtotal = vsync + vbp + vactive + vfp = 525\)
    \item 1 frame takes: \(vtotal \times htotal = 554400~t_{clk}\)\\
    60 frames take: \(vtotal \times htotal \times 60 = 33264000~t_{clk}\)\\
    60 fps requires: \(f_{clk} \geq 33.264~MHz\)
    \end{itemize}
  \end{minipage}
  \vspace{0.5em}

  \begin{itemize}
  \item Panels usually support a \textbf{range of timings}
  \item The pixel clock rate is often \textbf{rounded} (refresh rate not always strictly respected)
  \end{itemize}

\end{frame}

\begin{frame}{Side-channel and identification}
  \begin{itemize}
  \item Monitor display connectors often come with a \textbf{Display Data Channel} (DDC)
    \begin{itemize}
    \item Side-bus to allow communication between host and display
    \item Usually based on I2C, quite slow (\(\approx 100~kHz\))
    \end{itemize}
  \item DDC provides access to the \textbf{Extended Display Identification Data} (EDID)
    \begin{itemize}
    \item Contains the list of supported modes in a standard format
    \item Usually stored in an EEPROM at I2C address \(0x50\)
    \end{itemize}
  \item Another common monitor signal is \textbf{Hotplug Detect} (HPD)
    \begin{itemize}
    \item Connected to a pin of the connector, asserted with a cable plugged
    \item Can be wired to an interrupt pin to detect connection changes
    \end{itemize}
  \item Direct panel interfaces (not monitors) usually lack DDC, EDID and HPD
    \begin{itemize}
      \item Panel is always considered connected
      \item Modes need to be known in advance
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Extra display interface features and EDID extensions}
  \begin{itemize}
  \item The EDID standard keeps evolving and exposes new features through extensions
  \item Configuration data for each feature is embedded in the EDID
  \item More or less features are supported depending on the display interface
  \item Common extra display interface features:
    \begin{itemize}
    \item \textbf{Interlaced}: Every other pixel line is sent at a time, alternating between top-fields and bottom-fields; Allows faster refreshing for CRTs, needs deinterlacing for progressive panels;
    \item \textbf{Audio}: Send audio in addition to pixels, during blanking periods;
    \item \textbf{Stereoscopy}: Pixel data is split between two screens that show a different geometrical perspective, providing 3D perception;
    \item \textbf{Variable Refresh Rate} (VRR): Pixel data can be sent at any point and does not need to conform to a given refresh rate;
    \item \textbf{Consumer Electronic Control} (CEC): Remote control features on a dedicated bus;
    \item \textbf{High-Bandwidth Digital Content Protection} (HDCP): Anti-copy protection
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Types of display interfaces}
  \begin{itemize}
  \item Legacy display interfaces are usually \textbf{analog}:
  \begin{itemize}
    \item Transmission through a DAC-ADC encoder-decoder chain
    \item Lack of precision, noise and chain error: not pixel-perfect, capped
    \item Requires few signal pins (1 per color channel and sync or less)
  \end{itemize}
  \item Recent interfaces are usually \textbf{digital}:
    \begin{itemize}
    \item Encoded binary transmission, usually with dedicated clock
    \item Encoders contain a controller (logic) and a PHY (signal)
    \item Pixel data is expected to be bit-perfect \textit{(but noise still exists)}
    \end{itemize}
  \item Digital interfaces can be \textbf{parallelized}:
    \begin{itemize}
    \item One signal per color bit (e.g. 24 signals for 24-bit RGB), clock and sync
    \item One clock cycle for one pixel (low clock rate)
    \end{itemize}
  \item Or they can be \textbf{serialized}:
    \begin{itemize}
    \item Pixel data is sent over physical lanes (one or more)
    \item One clock cycle for one bit on each lane (high clock rate)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Types of display interfaces (illustrated)}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/display-interface-encoders.pdf}
  \end{center}
\end{frame}

\begin{frame}{VGA display interface}
  \begin{itemize}
  \item \textbf{Video Graphics Array} (VGA), since 1987 (IBM)
    \begin{itemize}
    \item \textbf{Analog} pixel data on 3 pins (R-G-B), DAC encoder to \(0.7~V\) peak-to-peak
    \item \textbf{Per-channel pixel streaming} (voltage change), following mode timings
    \item \textbf{Hsync} and \textbf{vsync} signals, I2C SDA and SDL \textbf{DDC} signals
    \item Hotplug detection with R/G/B pins \textbf{current sensing}
    \item Using a DB-15 connector for signals:
    \end{itemize}
  \begin{center}
    \includegraphics[height=2em]{slides/graphics-introduction/vga-pinout.pdf}
  \end{center}
  \begin{itemize}
  \item \textbf{Pixel}: Red, Green, Blue {\footnotesize(1, 2, 3)}, Ground returns {\footnotesize(6, 7, 8)}
  \item \textbf{Sync}: Hsync, Vsync {\footnotesize(13, 14)}
  \item \textbf{Side}: DDC SDA, DDC SCL {\footnotesize(12, 15)}
  \item \textbf{Power}: \(+5~V\) {\footnotesize(9)}, Ground {\footnotesize(10)}
  \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{VGA display interface (illustrated)}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/graphics-introduction/a13-olinuxino-vga.png}
  \end{center}

  \begin{itemize}
  \item Very basic VGA encoder from parallel signals, DDC excluded
  \item Resistor ladder for analog-to-digital conversion\\
  \textit{using SN74ALVC244 voltage level shifters (\(1.8~V\) to \(3.3~V\)), clamping diodes}
  \item 6 most-significant bits only, 2 least-significant bits set to 0\\
  \textit{D0-D1, D8-D9 and D16-D17 are not routed}
  \end{itemize}
\end{frame}

\begin{frame}{DVI display interface}
  \begin{itemize}
  \item \textbf{Digital Visual Interface} (DVI), since 1999 (DDWG)
    \begin{itemize}
    \item \textbf{DVI-A}: Analog only, comparable to VGA
    \item \textbf{DVI-D}: Digital only, single-link (3 data lanes) or dual-link (6 data lanes)
    \item \textbf{DVI-I}: Both analog and digital supported, single-link or dual-link
    \item Digital serial link using \textbf{Transition-Minimized Differential Signaling} (TMDS)
    \item Dedicated \textbf{DDC} and \textbf{HPD} signals
    \item Using a subset or variation of the full \textbf{DVI-I connector} for signals:
    \end{itemize}
  \begin{center}
    \includegraphics[height=2em]{slides/graphics-introduction/dvi-pinout.pdf}
  \end{center}
  \begin{itemize}
  \item \textbf{TMDS}: Data+ {\footnotesize(2, 5, 10, 13, 18, 21)}, Data- {\footnotesize(1, 4, 9, 12, 17, 20)}, Clock {\footnotesize(23, 24)}
  \item \textbf{Analog pixel}: Red, Green, Blue {\footnotesize(C1, C2, C3)}, Ground {\footnotesize(C5)}
  \item \textbf{Analog sync}: Hsync, Vsync {\footnotesize(C4, 8)}
  \item \textbf{Side}: DDC SDA, DDC SCL {\footnotesize(7, 6)}, HPD {\footnotesize(16)}
  \item \textbf{Power}: \(+5~V\) {\footnotesize(14)}, Ground {\footnotesize(15)}
  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{HDMI display interface}
  \begin{itemize}
  \item \textbf{High-Definition Multimedia Interface} (HDMI), since 2002 (HDMI Forum)
    \begin{itemize}
    \item Similar to \textbf{DVI-D}: no analog, 3 TMDS data lanes (R-G-B)
    \item Adding the use of AVI infoframes for meta-data and audio
    \item \textbf{High bandwidth} \((\leq 48~Gbit/s)\) (2.1) and clock speeds \((\leq 340~MHz)\)
    \item \textbf{Extra features}: Audio, CEC (1.2), HDR (1.3), 4K (1.4), Stereoscopy (1.4),\\8K-10K (2.1), DSC (2.1), HFR (\(120~Hz\)), per-frame HDR (2.1)
    \item Using a dedicated (and proprietary) \textbf{HDMI connector} for signals:
    \end{itemize}
  \begin{center}
    \includegraphics[height=2em]{slides/graphics-introduction/hdmi-pinout.pdf}
  \end{center}
  \begin{itemize}
  \item \textbf{TMDS}: Data+ {\footnotesize(1, 4, 7)}, Data- {\footnotesize(3, 6, 9)}, Clock {\footnotesize(10, 12)}
  \item \textbf{Side}: SDA, SCL {\footnotesize(16, 15)}, HPD {\footnotesize(19)}, CEC {\footnotesize(13)}
  \item \textbf{Power}: \(+5~V\) {\footnotesize(18)}, Ground {\footnotesize(17)}
  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{DP/eDP display interface}
  \begin{itemize}
  \item \textbf{DisplayPort} (DP), since 2008 (VESA)
    \begin{itemize}
    \item Digital serial link with 4 data lanes using \textbf{Low-Voltage Differential Signaling} (LVDS)
    or TMDS for DP Dual-Mode (DP++), compatible with DVI-D and HDMI
    \item Using \textbf{packets} for video/audio data and meta-data 
    \item Auxiliary channel encapsulating I2C DDC, CEC and more (e.g. USB)
    \item \textbf{High bandwidth} \((\leq 77.37~Gbit/s)\) (2.0)
    \item \textbf{Extra features}: Audio, CEC, HDR (1.4), 4K (1.3), Stereoscopy (1.2),\\8K (1.3-1.4),  10K-16K (2.0)
    \item \textbf{Multi-Stream Transport} (MST) to chain displays
    \item Using a dedicated (and proprietary) \textbf{DisplayPort connector} for signals:
    \end{itemize}
  \begin{center}
    \includegraphics[height=2em]{slides/graphics-introduction/dp-pinout.pdf}
  \end{center}
  \begin{itemize}
  \item \textbf{LVDS/TMDS}: ML+ {\footnotesize(1, 4, 7, 10)}, ML- {\footnotesize(3, 6, 9, 12)}
  \item \textbf{Side}: AUX+ (15), AUX- (17), HPD (18)
  \item \textbf{Power}: \(+3.3~V\) {\footnotesize(20)}, Ground {\footnotesize(2, 5, 8, 11, 16)}
  \end{itemize}
  \item \textbf{Embedded DisplayPort} (eDP) for internal panels (without connector)
  \end{itemize}
\end{frame}

\begin{frame}{LVDS and DSI display interfaces}

% TODO split and add photo of custom LVDS connector as well as a DSI panel (librem 5 dvt?)

  \begin{itemize}
  \item \textbf{Low Voltage Differential Signaling} (LVDS)
    \begin{itemize}
    \item Generic digital serial link with clock and data signals using LVDS
    \item Only sends pixel data according to a pre-defined mode (no DDC, no packets)
    \item For internal panels, exposed with specific connectors
    \item Common for laptop panels
    \end{itemize}
  \end{itemize}
  \begin{itemize}
  \item \textbf{Display Serial Interface} (DSI), since 2006 (MIPI)
    \begin{itemize}
    \item Digital serial link with clock and up to 4 data lanes using LVDS
    \item Using \textbf{packets} for video data and meta-data
    \item Commands for configuration can be issued with the \textbf{DSI Command Set} (DCS)\\
    \textit{Generic base with proprietary vendor-specific extensions}
    \item For internal panels, exposed with specific connectors
    \item Common for mobile devices' panels
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{DPI display interface}
  \begin{itemize}
  \item \textbf{Display Parallel Interface} (DPI)
    \begin{itemize}
    \item Generic parallel digital interface, with 1 signal per color bit, clock and sync
    \item Exists with different numbers of bits: 24 (8-8-8), 18 (6-6-6) or 16 (5-6-5)\\
    \textit{Dithering is required when using 16 or 18 bits}
    \item Sends pixel data bits following mode timings
    \item Base signals: color data bits, vsync, hsync
    \item Extra signals: display enable (DE)
    \item Beware: sync and DE signals can be active-high or active-low
    \item For internal panels, requires many signals
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Bridges/transcoders}
  \begin{itemize}
  \item Not every display interface is supported by the hardware at hand
  \item Bridges or transcoders are used to translate from one interface to another
  \item They are composed of a decoder and an encoder (in a single package)
  \item Usually standalone and transparent, often only replicate timings\\
  \textit{but some can have a side-bus for configuration and fine-tuning}
  \item Example: VGA interfaces are usually bridged from digital interfaces nowadays
  \end{itemize}

  \begin{center}
  \includegraphics[height=6em]{slides/graphics-introduction/dp-dvi-bridge.jpg}\\
  \textit{\small A DP to DVI bridge}
  \end{center}
\end{frame}

\subsection{Render Hardware Specifics}

\begin{frame}{Digital Signal Processors}
  \begin{itemize}
  \item Digital Signal Processors (DSPs) allow programmable image signal processing\\
    \textit{can also be used for implementing 2D rendering primitives}
  \item Using a dedicated Instruction Set Architectures (ISA)
  \item Arithmetic implementations are either:
    \begin{itemize}
    \item \textbf{fixed-point}: simple hardware implementation, fixed range (usually 16.16)\\
      \textit{16 bits for the integer part and 16 bits for the decimal part}
    \item \textbf{floating-point}: complex implementations, trade-off between range and precision
    \end{itemize}
  \item Usually more power-efficient than general-purpose CPUs
  \item Depending on the DSP, the software can be:
    \begin{itemize}
    \item A \textbf{standalone firmware}, usually developed from vendor libraries (C/C++/ASM)
    \item A \textbf{real-time operating system} (RTOS) application (C/C++/...)
    \end{itemize}
  \item Can be used standalone in a video pipeline or to offload a CPU
  \item Modern DSPs can be multi-core and feature various I/O controllers
  \end{itemize}
\end{frame}

\begin{frame}{Dedicated hardware accelerators}
  \begin{itemize}
  \item Fixed-function hardware can be used for accelerating specific operations
  \begin{itemize}
    \item Implemented as hardware circuits in Systems on a Chip (SoCs) or DSPs
    \item Implemented as logic configuration bitstream in FPGAs
  \end{itemize}
  \item Implement a configurable fixed pipeline for image operations
  \item Accessed and configured through specific registers exposed via a bus
    \begin{itemize}
    \item Global configuration registers to build the pipeline between blocks
    \item Configuration registers for each block
    \item Kick and status registers
    \end{itemize}
  \item Usually very power-efficient and very fast
  \end{itemize}
\end{frame}

\begin{frame}{Dedicated hardware accelerators (illustrated)}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{slides/graphics-introduction/g2d-block.png}\\
    \textit{A typical hardware pipeline for a 2D graphics block}\\
  \end{center}
\end{frame}

\begin{frame}{Graphics Processing Unit}
  \begin{itemize}
  \item Graphics Processing Units (GPUs) are 3D rendering hardware implementations\\
    \textit{the term no longer designates all graphics-processing hardware}
  \item Renders lists of vertices (points) in 3D space with lighting and textures
  \item Operates on graphics primitives: points (vertices), lines and triangles
  \item GPU hardware architectures evolved over time:
    \begin{itemize}
    \item From \textbf{fixed-function} configurable hardware block pipelines
    \item To pipelines with both fixed blocks and specialized \textbf{programmable} processing units
    \end{itemize}
  \item Shaders are programs that run at different steps of the pipeline:
    \begin{itemize}
    \item \textbf{vertex shaders}: define the position, texture coordinates and lighting of each vertex
    \item \textbf{geometry shaders}: generate new primitives from the provided ones
    \item \textbf{fragment/pixel shaders}: performs rasterisation for each output pixel
    \end{itemize}
  \item Using a \textbf{depth/z buffer} to keep track of the z-order for each output pixel
  \item Rasterization is optimized by eliminating hidden elements as early as possible
  \end{itemize}
\end{frame}

\begin{frame}{Graphics Processing Unit internals}
  \begin{itemize}
  \item Shader cores have highly-specialized ISAs adapted for geometry\\
    \textit{vector operations, hardware trigonometric implementations}
  \item Modern GPUs sometimes have a unified shader core
  \item Shading cores are duplicated to work in parallel (especially rasterization)
  \item Output is divided in tiles (clipping areas) and distributed to cores
  \item Each rasterized tile is written to the output framebuffer separately
  \item Extremely efficient compared to any general-purpose CPU\\
    \textit{GPUs are also used for general-purpose computing: GPGPU}
  \end{itemize}
\end{frame}

\subsection{System Integration, Memory and Performance}

\begin{frame}{Graphics integration and memory}
  \begin{itemize}
  \item Graphics devices integrated in larger systems need two main interfaces:
    \begin{itemize}
    \item \textbf{Control interface} (low speed): to program the device from the main CPU
    \item \textbf{Memory interface} (high speed): to read the source data and write their framebuffer
    \end{itemize}
  \item Other usual required elements: clocks, interrupts, reset
  \item Both the graphics device and the CPU need to access the memory
  \item Different types of memory used by graphics hardware:
    \begin{itemize}
    \item \textbf{graphics memory}: dedicated memory attached to the graphics device\\
    \textit{the memory is made available to the CPU through the memory interface}
    \item \textbf{dedicated system memory}: a reserved contiguous area of system memory\\
    \textit{required when the device has no mapping unit}
    \item \textbf{system memory pages}: any system memory page can be mapped for access\\
    \textit{for devices with a dedicated IOMMU and graphics address remapping table (GART)}
    \end{itemize}
  \item Since the two parties access the same memory, cache can become incoherent
  \item Cache must be \textbf{synchronized} before reading and after writing, or \textbf{disabled}
  \end{itemize}
\end{frame}

\begin{frame}{Graphics shared memory access}
  \begin{itemize}
  \item Concurrent access to memory can lead to trouble:
    \begin{itemize}
    \item Concurrent read-write accesses result in partially-updated data
    \item Concurrent write-write accesses result in incoherent data
    \end{itemize}
  \item Common issue with display hardware: tearing
    \begin{itemize}
    \item The framebuffer is scanned out at a fixed rate (e.g. \(60~fps\))
    \item Any modification during scan out will result in a partial update
    \item Creates an unpleasant visual glitch effect
    \end{itemize}
\begin{center}
\includegraphics[height=8em]{slides/graphics-introduction/tearing-glitch.jpg}
\end{center}
  \item Solved by using two buffers: double-buffering, switched with page flipping\\
    \textit{using more buffers is possible if rendering can be done in advance}
  \end{itemize}
\end{frame}

\begin{frame}{Graphics memory constraints and performance}
  \begin{itemize}
  \item Memory alignment, stride, tiled modes
  \end{itemize}
\end{frame}

\section{Software Aspects}

\subsection{Display Stack Overview}

\begin{frame}{System-agnostic overview: kernel}
  \begin{itemize}
  \item The kernel coordinates access to the hardware from userspace
  \item Handles register access, interrupts, etc
  \item Coordinates memory management with the rest of the system
  \item Exposes features to userspace through hardware-agnostic interfaces\\
  \textit{or at least, as much as possible}
  \item Three aspects are usually involved:
    \begin{itemize}
    \item \textbf{display}: from framebuffer to encoder
    \item \textbf{render}: GPU and/or 2D accelerators
    \item \textbf{input}: keyboard, mouse and other devices
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{System-agnostic overview: display userspace}
  \begin{itemize}
  \item Userspace needs to provide a way for applications to show buffers
  \item Many applications need to show their buffers concurrently
  \item The \textbf{display server} is in charge of coordinating between applications:
    \begin{itemize}
    \item Part of the core of the system, privileged
    \item Applications (via libraries) contact the server to display pixel buffers
    \item Dispatches input events to the concerned applications
    \item Only the display server deals with the kernel display and input APIs
    \end{itemize}
  \item The \textbf{compositor} merges pixel buffers from applications into the final buffer
  \item The \textbf{window manager} defines stacking order, focus, decorations, etc
  \item Both can be part of the display server or distinct components
  \end{itemize}
\end{frame}

\begin{frame}{System-agnostic overview: display userspace (illustrated)}

  \begin{minipage}[t]{0.49\textwidth}
    \centering
    \includegraphics[height=7em]{slides/graphics-introduction/compositing-gnome-shell.jpg}\\
    \textit{\small GNOME-Shell (green) displaying the\\ top-bar and background}\\
    \vspace{0.5em}
    \includegraphics[height=7em]{slides/graphics-introduction/compositing-gnome-terminal.jpg}\\
    \textit{\small GNOME-Terminal (green) with\\ window decorations (red)}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.49\textwidth}
    \centering
    \includegraphics[height=7em]{slides/graphics-introduction/compositing-lollypop.jpg}\\
    \textit{\small Lollypop (green) with\\ window decorations (red)}\\
    \vspace{0.5em}
    \includegraphics[height=7em]{slides/graphics-introduction/compositing-result.jpg}\\
    \textit{\small The composited result}
  \end{minipage}
\end{frame}

\begin{frame}{System-agnostic overview: render userspace}
  \begin{itemize}
  \item Graphics applications and libraries need to render visual elements
  \item Rendering can be a major \textbf{performance bottleneck}
  \item The system often provides \textbf{accelerated 2D primitives}:
    \begin{itemize}
    \item Either in the display server
    \item Either in dedicated libraries
    \end{itemize}
  \item Their implementation can take different forms:
    \begin{itemize}
    \item Using dedicated 2D hardware
    \item Using 3D hardware in 2D setups (\(z = 0\))
    \item Using specific efficient CPU instructions (SIMD)
    \item Using optimized generic algorithms
    \end{itemize}
  \item \textbf{3D rendering} comes with its own interfaces and libraries
  \item Usually with generic interfaces and hardware-specific implementations
  \end{itemize}
\end{frame}

\begin{frame}{System-agnostic overview (illustrated)}
  \begin{center}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/agnostic-display-stack-overview.pdf}
  \end{center}
\end{frame}

\begin{frame}{Linux kernel overview}
  \begin{itemize}
  \item \textbf{Input} subsystem
    \begin{itemize}
    \item Supports devices such as mice, keyboards, joysticks, touchscreens
    \item Legacy (unused) interfaces for keyboard, mice
    \item Unified \textbf{evdev} event interface to simplify userspace
    \end{itemize}
  \item \textbf{Framebuffer device} (fbdev) subsystem
    \begin{itemize}
    \item \textbf{Legacy} interface for displaying pixel buffers on-screen
    \item Very limited pipeline configuration, no hotplug support
    \item Extended features added through driver-specific interfaces
    \end{itemize}
  \item \textbf{Direct Rendering Manager} (DRM) subsystem
    \begin{itemize}
    \item Unified display configuration interface: \textbf{Kernel Mode Setting} (KMS or DRM mode)
    \item Allows synchronizing changes together (DRM atomic)
    \item Exposes render devices through driver-specific interfaces (DRM render)\\
      \textit{Mostly for 3D rendering with GPUs, but a few 2D devices too}
    \item Provides memory management mechanisms (DRM GEM)
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Linux-compatible low-level userspace overview}
  \begin{itemize}
  \item \textbf{Input} low-level libraries
    \begin{itemize}
    \item \textbf{libevdev} (C): Wrapper for evdev interface system calls
    \item \textbf{libinput} (C): Input device management, abstraction and quirks, using libevdev
    \end{itemize}
  \item \textbf{Display/render} low-level interface library
    \begin{itemize}
    \item \textbf{libdrm} (C): Wrapper for DRM system calls
    \end{itemize}
  \item \textbf{2D render} low-level libraries
    \begin{itemize}
    \item \textbf{Pixman} (C): Optimized pixel-level operations
    \item \textbf{Cairo} (C): Optimized vector drawing (can use 3D)
    \item \textbf{Skia} (C): Optimized vector drawing from Google (can use 3D)
    \item \textbf{Clutter} (C++): Accelerated UI animation (using 3D)
    \end{itemize}
  \item \textbf{3D render} low-level libraries
    \begin{itemize}
    \item \textbf{Mesa 3D} (C): Reference free software OpenGL implementation
    \item \textbf{Proprietary vendor implementations} for specific hardware
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{X Window overview}
  \begin{itemize}
  \item \textbf{X Window} overview
    \begin{itemize}
    \item \textbf{X Window/X11} is the historical (and \textbf{legacy}) \textbf{display protocol}
    \item Complemented by numerous protocol \textbf{extensions} for extra features
    \item \textbf{X.org} is the reference X11 server \textbf{implementation}
    \item Needs an external \textbf{window manager} to handle multiple applications
    \item \textbf{Composition} by the server or the window manager (Composite extension)
    \end{itemize}
  \end{itemize}
  \begin{minipage}[b]{0.8\textwidth}
  \begin{itemize}
  \item \textbf{Window manager} implementations examples
    \begin{itemize}
    \item \textbf{Mutter}: GNOME accelerated compositing window manager
    \item \textbf{i3}: Popular tiling window manager
    \item \textbf{Compiz}: Popular 3D-enabled compositing window manager
    \end{itemize}
  \item \textbf{Display client} libraries
    \begin{itemize}
    \item \textbf{Xlib} (C): The legacy X11 client-side protocol library helper
    \item \textbf{XCB} (C): The updated X11 client-side protocol library helper
    \item Integrated in most higher-level graphics-oriented libraries
    \end{itemize}
  \end{itemize}
  \end{minipage}
  \begin{minipage}[b]{0.15\textwidth}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/x11-logo.pdf}
  \end{minipage}
\end{frame}

\begin{frame}{Wayland overview}
  \begin{itemize}
  \item \textbf{Wayland} overview
    \begin{itemize}
    \item Wayland is a \textbf{display protocol} (with a core and extensions), not an implementation
    \item Replaces X11 with a \textbf{less intrusive, more modern and minimal} paradigm
    \item Server implementation is in charge of \textbf{input, composition and window management}
    \item Window decorations can be drawn by the client or the server
    \end{itemize}
  \end{itemize}
  \begin{minipage}[b]{0.8\textwidth}
  \begin{itemize}
  \item \textbf{Wayland compositor} implementations examples
    \begin{itemize}
    \item Using the \textbf{libwayland-server} base protocol library
    \item \textbf{Weston/libweston}: Reference implementation
    \item \textbf{Sway/wlroots}: Tiling window manager and base library
    \item \textbf{Mutter}: GNOME compositor, expecting client-side decorations
    \end{itemize}
  \item \textbf{Display client} libraries
    \begin{itemize}
    \item Using the \textbf{libwayland-client} base protocol library
    \item Integrated in many higher-level graphics-oriented libraries
    \end{itemize}
  \end{itemize}
  \end{minipage}
  \begin{minipage}[b]{0.15\textwidth}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/wayland-logo.pdf}
  \end{minipage}
\end{frame}

\begin{frame}{High-level graphics libraries and desktop environments overview}
  \begin{minipage}[b]{0.09\textwidth}
  \centering
  \includegraphics[width=\textwidth]{slides/graphics-introduction/gtk-logo.pdf}\\
  \vspace{3em}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/qt-logo.pdf}\\
  \vspace{3em}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/sdl-logo.png}\\
  \vspace{2em}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.8\textwidth}
  \begin{itemize}
  \item Applications rarely to never use Wayland or X11 directly
  \item Drawing and managing a user interface is complex
  \item Widely-used high-level graphics libraries (aka toolkits)
    \begin{itemize}
    \item \textbf{GTK} (C): Widget-based UI toolkit, drawing helpers (GDK)
    \item \textbf{Qt} (C++): Widget-based UI toolkit, wide framework
    \item \textbf{EFL} (C): Lightweight UI and application library
    \item \textbf{SDL} (C): Drawing-oriented graphics library (used in games)
    \end{itemize}
  \item A desktop environment groups related libraries and components\\
  \textit{gives a consistent look and feel across the system}
  \item \textbf{Desktop environment} examples
    \begin{itemize}
    \item \textbf{GNOME}: Using GTK, GNOME-Shell desktop
    \item \textbf{KDE}: Using Qt, Plasma desktop
    \item \textbf{Xfce}: Using GTK, lightweight
    \item \textbf{Enlightenment}: Using EFL
    \end{itemize}
  \end{itemize}
  \vfill~
  \end{minipage}
  \begin{minipage}[b]{0.09\textwidth}
  \centering
  \includegraphics[width=\textwidth]{slides/graphics-introduction/gnome-logo.pdf}\\
  \vspace{1em}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/kde-logo.pdf}\\
  \vspace{1em}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/xfce-logo.pdf}\\
  \vspace{0.5em}
  \includegraphics[width=\textwidth]{slides/graphics-introduction/enlightenment-logo.pdf}
  \end{minipage}
\end{frame}

\subsection{Kernel Aspects}

\begin{frame}{Linux TTY subsystem introduction}
  \begin{itemize}
  \item The \textbf{TTY} subsystem handles teletypewriters to send/receive characters
  \item Source code located at \code{drivers/tty} in Linux
  \item Supports physical instances (e.g. UART, RS-232) and virtual ones
  \item Virtual terminals/consoles (VTs/VCs) associate a distinct keyboard and display
    \begin{itemize}
    \item Many VTs are created by Linux, available under \code{/dev/tty*}
    \item Only a single VT is active at a time, switched with \code{Ctrl + Alt + Fi}
    \item Display grabbed using \textbf{fbcon} from the \textbf{fbdev} subsystem
    \item Keyboard grabbed using the \textbf{input} subsystem
    \item Can be used to show kernel messages (\code{console=tty1} in the cmdline)
    \item Every program runs under a controlling tty (given by the \code{tty} command)
    \end{itemize}
  \item Pseudo-terminals also exist, for software-based I/O only
    \begin{itemize}
    \item Created by programs (e.g. terminal emulator) under \code{/dev/pts/*}
    \item Unrelated to graphics topics
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Virtual terminals and graphics}
  \begin{itemize}
  \item With VTs, the kernel is \textbf{already using} the display and keyboard!
  \item Display servers need to switch to \textbf{graphics mode} to release the display:
  \begin{minted}[fontsize=\small]{console}
ret = ioctl(tty_fd, KDSETMODE, KD_GRAPHICS);
  \end{minted}
  \item And disable \textbf{keyboard support} on the standard input:
  \begin{minted}[fontsize=\small]{console}
ret = ioctl(tty_fd, KDSKBMODE, K_OFF);
  \end{minted}
  \item The display device can then be used \textbf{exclusively}
  \item Input is no longer interpreted (e.g. \code{Ctrl-C} is ignored)
  \item Graphics and keyboard mode must be restored when leaving to keep the VT usable
  \item Current modes can be queried with:
  \begin{minted}[fontsize=\small]{console}
short mode, kbmode;
ret = ioctl(tty_fd, KDGETMODE, &mode);
ret = ioctl(tty_fd, KDGKBMODE, &kbmode);
  \end{minted}
  \item More details in the \code{console_ioctl} man page
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Virtual terminals switching and graphics}
  \begin{itemize}
  \item However, the user might still want to switch VTs!
  \item So the display device must be \textbf{released/reacquired} for VT switching
  \item Unix signals are used to notify the application, configured with:
  \begin{minted}[fontsize=\small]{console}
struct vt_mode vt_mode = { 0 };
vt_mode.mode = VT_PROCESS;
vt_mode.relsig = SIGUSR1;
vt_mode.acqsig = SIGUSR2;
ret = ioctl(tty_fd, VT_SETMODE, &vt_mode);
  \end{minted}
  \item VT switching must be acknowledged for the other VT to take over:
  \begin{minted}[fontsize=\small]{console}
ret = ioctl(tty_fd, VT_RELDISP, VT_ACKACQ); /* when entering VT */
ret = ioctl(tty_fd, VT_RELDISP, 1); /* when leaving VT */
  \end{minted}
  \item Failure to acknowledge will cause a \textbf{system hang}
  \end{itemize}
\end{frame}

\begin{frame}{DRM devices}
  \begin{itemize}
  \item Unix-style devices are identified with major/minor numbers
    \begin{itemize}
    \item More details in the \code{makedev} manpage, using \code{dev_t} type
    \item Minor/major can be retrieved with \code{stat/fstat}
    \item DRM major in Linux is \textbf{226}
    \end{itemize}
  \item Two types of DRM devices exist:
    \begin{itemize}
    \item \textbf{Primary} nodes at \code{/dev/dri/card*} with minor \(< 128\)\\
    Used for display operations with the KMS (mode) interface
    \item \textbf{Render} nodes at \code{/dev/dri/renderD*} with minor \(\geq 128\)\\
    Used for render operations with a driver-specific interface
    \end{itemize}
  \item DRM devices can also be used by the kernel directly (internal clients):
    \begin{itemize}
    \item \textbf{fbdev} compatibility layer to provide \code{/dev/fb*} nodes
    \item Used by \textbf{fbcon} to provide virtual consoles
    \end{itemize}
  \item Userspace needs rights to open device nodes:
    \begin{itemize}
    \item Usually allowed via the \code{video} \textbf{group} or \textbf{Access Control Lists} (ACLs)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM driver identification and capabilities}
  \begin{itemize}
  \item Driver-specific \textbf{name and version} (major/minor/patchlevel) can be queried:%
  \begin{minted}[fontsize=\small]{console}
struct drm_version version = { ... };
ret = ioctl(drm_fd, DRM_IOCTL_VERSION, &version);
  \end{minted}
  \item Drivers expose specific \textbf{capabilities}, that can be queried:
  \begin{minted}[fontsize=\small]{console}
struct drm_get_cap get_cap = { 0 };
get_cap.capability = DRM_CAP_DUMB_BUFFER;
ret = ioctl(drm_fd, DRM_IOCTL_GET_CAP, &get_cap);
  \end{minted}
  \item The kernel \textbf{must} be informed of client support for some features:
  \begin{minted}[fontsize=\small]{console}
struct drm_set_client_cap client_cap = { 0 };
client_cap.capability = DRM_CLIENT_CAP_UNIVERSAL_PLANES;
client_cap.value = 1;
ret = ioctl(drm_fd, DRM_IOCTL_SET_CLIENT_CAP, &client_cap);
  \end{minted}
  \item Driver and client capabilities defined in Linux's \kfile{include/uapi/drm/drm.h}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM master, magic and authentication}
  \begin{itemize}
  \item Multiple userspace clients can open the same primary device node
  \item Only the \textbf{master} client is allowed to configure display (KMS)
  \item Master is exclusive and can be \textbf{acquired} and \textbf{dropped} (VT switching):
  \begin{minted}[fontsize=\small]{console}
ret = ioctl(drm_fd, DRM_IOCTL_SET_MASTER, NULL);
ret = ioctl(drm_fd, DRM_IOCTL_DROP_MASTER, NULL);
  \end{minted}
  \item Requires \code{CAP_SYS_ADMIN} Linux capability, see \code{capabilities} man page\\
    \textit{usually reserved to the root super user}
  \item Some operations can be allowed on trusted clients with \textbf{magic authentication}:
  \begin{enumerate}
  \item Client \textit{foo} gets its client-specific magic:
  \begin{minted}[fontsize=\small]{console}
struct drm_auth auth = { 0 };
ret = ioctl(drm_fd, DRM_IOCTL_GET_MAGIC, &auth);
  \end{minted}
  \item Client \textit{foo} sends \code{auth.magic} to master client \textit{bar} (via IPC)
  \item Master client \textit{bar} authenticates client \textit{foo}:
  \begin{minted}[fontsize=\small]{console}
ret = ioctl(drm_fd, DRM_IOCTL_AUTH_MAGIC, &auth);
  \end{minted}
  \end{enumerate}
  \item Mostly for allocating buffers on another process
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM memory management}
  \begin{itemize}
  \item The \textbf{Graphics Execution Manager} (GEM) handles memory in DRM
  \item Used both by KMS and render drivers, with specific backends:
    \begin{itemize}
    \item \textbf{CMA}: Contiguous Memory Allocator (reserved area at boot)
    \item \textbf{Shmem}: Shared system memory (anonymous pages)
    \item \textbf{Vram}: Video RAM, using the \textbf{Translation Table Manager} (TTM)
    \end{itemize}
  \item Ensures buffers \textbf{coherency} on access (cache management)
  \item Allocated buffers are identified with a unique \textbf{handle} number
  \item In KMS, the \textbf{dumb buffer} API exposes memory operations:
    \begin{itemize}
    \item For memory used for \textbf{scanout framebuffers}
    \item Drivers calculate aligned pitch/stride and size based on dimensions and bpp
    \item Sometimes too limiting (e.g. multi-planar formats)
    \end{itemize}
  \item More details in the \textit{drm-memory} man page
  \item Drivers sometimes expose extra \code{ioctls} for more advanced needs
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS dumb buffer API}
  \begin{itemize}
  \item \textbf{Allocating} from \code{width}, \code{height} and \code{bpp}, returning \code{handle}, \code{pitch} and \code{size}:\\
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_create_dumb create_dumb = { ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb);
  \end{minted}
  \item \textbf{Destroying} an allocated buffer:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_destroy_dumb destroy_dumb = { .handle = ..., };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_dumb);
  \end{minted}
  \item \textbf{Preparing a mapping} in user memory for a buffer, returning an \code{offset}:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_map_dumb map_dumb = { .handle = ..., };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb);
  \end{minted}
  \item \textbf{Mapping memory} to userspace using the \code{offset}:
  \begin{minted}[fontsize=\small]{console}
map = mmap(NULL, create_dumb.size, PROT_READ | PROT_WRITE, MAP_SHARED,
           drm_fd, map_dumb.offset);
  \end{minted}
  \item \textbf{Unmapping} memory after use:
  \begin{minted}[fontsize=\small]{console}
munmap(map, create_dumb.size);
  \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM FourCCs and modifiers}
  \begin{itemize}
  \item DRM has its own representation of \textbf{pixel formats}, with FourCC codes (on 32 bits)
  \item Defined in the \kfile{include/uapi/drm/drm_fourcc.h} header
  \item They can specify up to 4 distinct \textbf{data planes} for color components
  \item Pixel formats are named "MSB-to-LSB" and specified in \textbf{little-endian} order\\
  \textit{LSB comes first in memory in little-endian}
  \item For instance, \code{DRM_FORMAT_XRGB8888} has the \code{B} byte first in memory\\
  \textit{Memory order is independent from the CPU or hardware endianness}
  \item A format \textbf{modifier} (on 64 bits) indicates the pixel order in memory
  \item \code{DRM_FORMAT_MOD_LINEAR} indicates raster order\\
  \textit{line-major left-to-right, top-to-bottom}
  \item Other modifiers are usually hardware-specific, often tiled\\
  (e.g. \code{DRM_FORMAT_MOD_VIVANTE_TILED})
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS resources probing}
  \begin{itemize}
  \item KMS hardware resources are exposed through the following entities:
    \begin{itemize}
    \item Connectors
    \item Encoders
    \item CRTCs
    \item Planes: primary, overlay and cursor
    \item Framebuffers
    \end{itemize}
  \item Each resource instance is identified with a unique \textbf{identification number}
  \item The list of resource ids is retrieved with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_card_res res = { ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETRESOURCES, &res);
  \end{minted}
  \item Plane ids (that were introduced later) are retrieved with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_get_plane_res res = { ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETPLANERESOURCES, &res);
  \end{minted}
  \item Resource ids are used with subsequent resource-specific calls
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS connector probing}
  \begin{itemize}
  \item The starting point to configure a KMS pipeline is the connector
  \item Current connector state is probed with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_get_connector get_connector = { .connector_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETCONNECTOR, &get_connector);
  \end{minted}
  \item \code{struct drm_mode_get_connector} exposes various information:
    \begin{itemize}
    \item Connector type and connection state
    \item Possible encoders, currently-attached encoder
    \item Available modes and physical monitor size
    \end{itemize}
  \item Probing modes triggers EDID read: optional and usually quite slow
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS modes}
  \begin{itemize}
  \item A display mode is represented as a \code{struct drm_mode_modeinfo} in DRM
  \item Members: \code{clock}, \code{[hv]display}, \code{[hv]sync_start}, \code{[hv]sync_end}, \code{[hv]total} and \code{flags} for signal-specific details (polarities)
  \item Diagram from \kfile{include/drm/drm_modes.h}:
  \begin{minted}[fontsize=\small]{console}
         Active                 Front           Sync           Back
         Region                 Porch                          Porch
<-----------------------><----------------><-------------><-------------->
  //////////////////////|
 ////////////////////// |
//////////////////////  |..................               ................
                                           _______________
<----- [hv]display ----->
<------------- [hv]sync_start ------------>
<--------------------- [hv]sync_end --------------------->
<-------------------------------- [hv]total ----------------------------->*
  \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS encoder probing}
  \begin{itemize}
  \item The next step is to find which CRTC id can be used with the connector
  \item The encoder is the link between the connector and CRTC
  \item Current encoder state can be probed with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_get_encoder get_encoder = { .encoder_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETENCODER, &get_encoder);
  \end{minted}
  \item \code{struct drm_mode_get_connector} exposes some information:
    \begin{itemize}
    \item Encoder type
    \item Possible CRTCs, currently-attached CRTC
    \end{itemize}
  \item This allows selecting the CRTC to use for the connector!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS framebuffer management}
  \begin{itemize}
  \item Framebuffers in DRM are described with a number of parameters :
    \begin{itemize}
    \item Picture-wide: \code{width}, \code{height}, \code{pixel_format}
    \item Plane-specific: GEM \code{handle}, \code{pitch}, \code{offset} and \code{modifier}
    \end{itemize}
  \item Up to 4 memory planes are supported (depending on the format)
  \item Allows supporting a wide range of possible configurations
  \item Flags are passed to indicate that modifiers or interlaced scan are used
  \item Framebuffers are registered from their parameters, returning a \code{fb_id}:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_fb_cmd2 fb_cmd2 = { ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_ADDFB2, &fb_cmd2);
  \end{minted}
  \item They are destroyed using the \code{fb_id}:
  \begin{minted}[fontsize=\small]{console}
unsigned int fb_id = fb_cmd2.fb_id;
ret = ioctl(drm_fd, DRM_IOCTL_MODE_RMFB, &fb_id);
  \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS CRTC configuration (legacy)}
  \begin{itemize}
  \item The pipeline can then be configured with the connector and the CRTC
  \item The current CRTC configuration can be retrieved with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_crtc crtc = { .crtc_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETCRTC, &crtc);
  \end{minted}
  \item The CRTC is configured with the connector id
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_crtc crtc = { .crtc_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_SETCRTC, &crtc);
  \end{minted}
  \item A mode and a framebuffer can be set (previous setup used otherwise)\\
  \textit{mandatory if the CRTC was unused before}
  \item The kernel will automatically select the best encoder for the connector and CRTC
  \item \textbf{Legacy and deprecated} way to do modesetting: only concerns the primary plane
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS page flipping (legacy)}
  \begin{itemize}
  \item Page flipping is the action of switching the CRTC to another framebuffer\\
  \textit{only concerns the primary plane}
  \item An event can be requested when the flip happens
  \item Can be scheduled at different times (specified with \code{flags}):
    \begin{itemize}
    \item At a specified vblank target (absolute or relative) to avoid tearing
    \item As soon as possible (asynchronously) if supported
    \end{itemize}
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_crtc_page_flip page_flip = { .crtc_id = ..., .fb_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_PAGE_FLIP, &page_flip);
  \end{minted}
  \item \textbf{Legacy and deprecated}: limited to the primary plane
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS overlay plane configuration (legacy)}
  \begin{itemize}
  \item Overlay planes are configured separately from the CRTC main plane
  \item The current state of a plane can be retrieved with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_get_plane get_plane = { .plane_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETPLANE, &get_plane);
  \end{minted}
  \item Provides possible CRTCs, current framebuffer and supported formats
  \item Planes are configured with source and destination parameters:
    \begin{itemize}
    \item \code{crtc_[xywh]}: On-CRTC position and dimensions
    \item \code{src_[xywh]}: In-framebuffer position and dimensions (source clipping area)
    \end{itemize}
  \item Configuration takes place with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_set_plane set_plane = { .plane_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_SETPLANE, &set_plane);
  \end{minted}
  \item \textbf{Legacy and deprecated}: not synchronized to vblank or page flip
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS cursor configuration and position (legacy)}
  \begin{itemize}
  \item Cursor planes have a separate dedicated legacy API
  \item Configured per-CRTC with a GEM \code{handle} and dimensions (\code{width}, \code{height})\\
  \textit{a zero GEM \code{handle} deconfigures and removes the cursor}
  \item Only supports the \code{DRM_FORMAT_ARGB8888} format (not configurable)
  \item Using a single \code{ioctl} with the \code{flags} field for the operation
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_cursor cursor = { .flags = DRM_MODE_CURSOR_BO,
                                  .crtc_id = ...};
ret = ioctl(drm_fd, DRM_IOCTL_MODE_CURSOR, &cursor);
  \end{minted}
  \item Once configured, the cursor can be moved to \code{x}, \code{y} on-CRTC coordinates
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_cursor cursor = { .flags = DRM_MODE_CURSOR_MOVE,
                                  .crtc_id = ... };
ret = ioctl(drm_fd, DRM_IOCTL_MODE_CURSOR, &cursor);
  \end{minted}
  \item \code{DRM_IOCTL_MODE_CURSOR2} variant provides cursor hotspot for virtual machines
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM event notifcation and wait}
  \begin{itemize}
  \item DRM provides an event notification mechanism for \textbf{vblank} and \textbf{page flip done}
  \item Available through the primary (KMS) file descriptor
  \item Can be used with \code{poll} and \code{select} (integrated in main loop)
  \item Events with a \code{struct drm_event} base are read using \code{read}
  \item Expand to \code{struct drm_event_vblank} for vblank and page flip done events\\
    \textit{only complete events are returned, so the buffer must be large enough}
  \item Events can be requested at page flip time or explicitly:
  \begin{minted}[fontsize=\small]{console}
union drm_wait_vblank wait_vblank = { .request = ... };
ret = ioctl(drm_fd, DRM_IOCTL_WAIT_VBLANK, &wait_vblank);
  \end{minted}
  \item A blocking wait for an absolute or relative vblank sequence can also be requested\\
  \textit{using the same \code{ioctl} and dedicated \code{request.type} values}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS object properties}
  \begin{itemize}
  \item KMS objects expose generic (or driver-specific) properties with names and values
  \textit{concerns \textbf{connectors}, \textbf{CRTCs} and \textbf{planes}}
    \begin{itemize}
    \item \textbf{Range} properties: limits for the value (signed or unsigned)
    \item \textbf{Enum} properties: fixed values with associated names for the values
    \item \textbf{Blob} properties: raw data with a given length
    \end{itemize}
  \item Properties have a \textbf{unique identifier across objects}, details can be queried:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_obj_get_property get_property = { .prop_id = ... }
ret = ioctl(drm_fd, DRM_IOCTL_MODE_GETPROPERTY, &get_property);
  \end{minted}
  \item Registered properties of an object can be retrieved using:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_obj_get_properties get_properties = { .obj_id = ... }
ret = ioctl(drm_fd, DRM_IOCTL_MODE_OBJ_GETPROPERTIES, &get_properties);
  \end{minted}
  \item The \code{value} of a property can be assigned with:
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_obj_set_property set_property = { .obj_id = ..., .prop_id = ... }
ret = ioctl(drm_fd, DRM_IOCTL_MODE_OBJ_SETPROPERTY, &set_property);
  \end{minted}
  \item Blob properties need to be created and destroyed (with their own identifier)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS atomic}
  \begin{itemize}
  \item The legacy API comes with major design issues:
    \begin{itemize}
    \item Overlay and cursor plane updates are applied instantly (tearing)
    \item Plane updates cannot be synchronized together (intermediate states)
    \item No way to check that setup is valid before applying it
    \end{itemize}
  \item The atomic API lifts these restrictions with a new paradigm:
    \begin{itemize}
    \item Objects are configured based on their KMS properties\\
    \textit{values are affected to each changed property}
    \item Property changes of different objects are grouped in an \textbf{atomic commit}
    \item Planes are handled regardless of their type (primary, overlay, cursor)
    \item Commits can be marked for test only: checked but not applied
    \item Changes are applied at next vblank, unless marked asynchronous
    \end{itemize}
  \begin{minted}[fontsize=\small]{console}
struct drm_mode_atomic atomic = { ... }
ret = ioctl(drm_fd, DRM_IOCTL_MODE_ATOMIC, &atomic);
  \end{minted}
  \item Unless marked non-blocking, the \code{ioctl} returns when changes are applied
  \item A page flip event can also be requested
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS atomic common properties}
  \begin{itemize}
  \item Common properties used to configure \textbf{connectors}:
    \begin{itemize}
    \item \code{CRTC_ID}: id of the CRTC to bind with the connector
    \end{itemize}
  \item Common properties used to configure \textbf{CRTCs}:
    \begin{itemize}
    \item \code{ACTIVE}: whether the CRTC is in use
    \item \code{MODE_ID}: id of the property blob with the \code{struct drm_mode_modeinfo} mode
    \end{itemize}
  \item Common properties used to configure \textbf{planes}:
    \begin{itemize}
    \item \code{FB_ID}: id of the framebuffer to bind with the plane
    \item \code{CRTC_ID}: id of the CRTC to bind with the plane
    \item \code{CRTC_[XYWH]}: on-CRTC position and dimensions of the plane
    \item \code{SRC_[XYWH]}: in-framebuffer position and dimensions (source clipping area)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM KMS atomic driver walkthrough}
  \begin{itemize}
  \item A state-of-the-art DRM KMS driver: \code{vc4} at \kdir{drivers/gpu/drm/vc4}\\
  \textit{integrates both DRM KMS and render}
  \item Entry point at \kfile{drivers/gpu/drm/vc4/vc4_drv.c}
  \item Dedicated documentation: \url{https://dri.freedesktop.org/docs/drm/gpu/vc4.html}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM render generalities}
  \begin{itemize}
  \item DRM render drivers have their own \textbf{driver-specific API}\\
    \textit{unlike KMS, render hardware abstraction is done in userspace}
  \item Their API is exposed through custom \code{ioctls}
  \item Can be associated with a KMS driver (e.g. \code{vc4}) or separate (e.g. \code{v3d})
  \item Drivers handle memory, job submission and scheduling, interrupts
  \item DRM has a common scheduler (from AMD) in \kdir{drivers/gpu/drm/scheduler}
  \item Usual operations:
    \begin{itemize}
    \item Managing buffer objects (BOs) of different types (create, destroy, mmap)\\
    \textit{using GEM under the hood}
    \item Submitting job data structures for programming the GPU (command lists)\\
    \textit{with a validation step to ensure its validity}
    \item Waiting for operations to complete
    \item Exposing performance-related information
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM render driver walkthrough}
  \begin{itemize}
  \item A state-of-the-art DRM render driver: \code{v3d} at \kdir{drivers/gpu/drm/v3d}
  \item Entry point at \kfile{drivers/gpu/drm/v3d/v3d_drv.c}
  \item Dedicated documentation: \url{https://dri.freedesktop.org/docs/drm/gpu/v3d.html}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM Prime zero-copy memory sharing (dma-buf)}
  \begin{itemize}
  \item Memory buffers often need to be shared between different devices\\
    \textit{e.g. DRM KMS and DRM render but also concerns V4L2 for media devices}
  \item The kernel-wide \code{dma-buf} API allows exporting and importing buffers
  \item Buffers are represented as \textbf{file descriptors} in userspace\\
    \textit{file descriptors can be shared between programs via IPC}
  \item DRM exposes dma-buf via the \textbf{DRM Prime} API
  \item DRM prime exports a GEM \code{handle} to a returned \code{fd}:
  \begin{minted}[fontsize=\small]{console}
struct drm_prime_handle prime_handle = { .handle = ... }
ret = ioctl(drm_fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &prime_handle);
  \end{minted}
  \item And vice-versa:
  \begin{minted}[fontsize=\small]{console}
struct drm_prime_handle prime_handle = { .fd = ... }
ret = ioctl(drm_fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &prime_handle);
  \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM sync object fencing}
  \begin{itemize}
  \item In a multi-device pipeline with zero-copy, only scheduling is left to userspace\\
  \textit{each device signals completion and userspace moves on to the next}
  \item Fences were introduced to avoid the extra roundtrip in userspace:
    \begin{itemize}
    \item The flow of buffers between devices is usually known in advance
    \item The kernel can coordinate internally and trigger the next device
    \item Requires submitting all commands in advance with fences attached
    \end{itemize}
  \item DRM exposes fences via the \textbf{Sync object} API
  \item Sync objects contain one fence, exposed as a file descriptor
  \item The KMS atomic API and some render driver APIs take input fence fds
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM sync object fencing}
  \begin{itemize}
  \item Sync objects are created and destroyed with a \code{handle}:
  \begin{minted}[fontsize=\small]{console}
struct drm_syncobj_create syncobj_create = { 0 }
ret = ioctl(drm_fd, DRM_IOCTL_SYNCOBJ_CREATE, &syncobj_create);
  \end{minted}
  \begin{minted}[fontsize=\small]{console}
struct drm_syncobj_destroy syncobj_destroy = { .handle = syncobj_create.handle }
ret = ioctl(drm_fd, DRM_IOCTL_SYNCOBJ_DESTROY, &syncobj_destroy);
  \end{minted}
  \item An output fence's \code{fd} is exported from a device's sync object with:
  \begin{minted}[fontsize=\small]{console}
struct drm_syncobj_handle syncobj_handle = { .handle = handle, ... }
ret = ioctl(drm_fd, DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD, &syncobj_handle);
  \end{minted}
  \item An input fence's \code{fd} is imported to a device's sync object with:
  \begin{minted}[fontsize=\small]{console}
struct drm_syncobj_handle syncobj_handle = { .handle = handle, .fd = fd }
ret = ioctl(drm_fd, DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE, &syncobj_handle);
  \end{minted}
  \item Quite a recent feature, not yet available in V4L2 (media)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{DRM debug and documentation}
  \begin{itemize}
  \item \textbf{Debug message} using the \code{drm.debug} kernel cmdline argument:
    \begin{itemize}
    \item Detailed in the \kfile{include/drm/drm_print.h} header
    \item \code{drm.debug=0x17} for core, KMS, driver and atomic debug messages
    \item \code{drm.debug=0x3f} for all debug messages
    \end{itemize}
  \item Current \textbf{state debug} in debugfs:\\\code{cat /sys/kernel/debug/dri/0/state}
  \item \textbf{Debug utility}: \code{modetest} from \code{libdrm}
  \item \textbf{Community} contact:
    \begin{itemize}
    \item Mailing list: \code{dri-devel@lists.freedesktop.org}
    \item IRC channel: \code{#dri-devel} on the Freenode network
    \end{itemize}
  \item \textbf{Documentation} resources:
    \begin{itemize}
    \item Linux GPU Driver Developers Guide: \url{https://www.kernel.org/doc/html/latest/gpu/index.html}
    \item Man pages about userspace aspects: \code{drm}, \code{drm-kms}, \code{drm-memory}
    \end{itemize}
  \end{itemize}
\end{frame}

% XXX: Add list of relevant code in wayland/xorg?

\subsection{Userspace Aspects}

\begin{frame}{libdrm wrapper}
  \begin{itemize}
  \item Userspace access to DRM devices is wrapped with \textbf{libdrm}
  \item Exposes convenience wrappers, helpers and some data structures around \code{ioctls}
    \begin{itemize}
    \item For KMS support in the \code{libdrm.so} library
    \item For hardware-specific render drivers in dedicated libraries (e.g. \code{libdrm_nouveau.so})
    \end{itemize}
  \item Used by almost every userspace project dealing with DRM:\\
    \textit{weston, mutter, Xorg, mesa, etc}
  \end{itemize}

  \begin{center}
  \includegraphics[width=0.5\textwidth]{slides/graphics-introduction/libdrm-userspace.pdf}
  \end{center}
\end{frame}

\begin{frame}{X11 protocol}
  \begin{itemize}
  \item X11 core protocol implemented by Xorg:
    \begin{itemize}
    \item Asynchronous packet-based system with different types:\\
    \code{Request}, \code{Reply}, \code{Event} and \code{Error} packets
    \item Can be used locally (UNIX socket) or over network (TCP/IP)
    \end{itemize}
  \item Clients fill the contents of \textbf{drawables}: pixmaps and windows
  \item Displayed data is held by the server and must be uploaded by the client\\
    \textit{but does not guarantee data retention and can ask for redraw}
  \item Windows are represented as a tree:
    \begin{itemize}
    \item Starting with the root window created by X
    \item Top-level windows and sub-windows can be created by clients
    \end{itemize}
  \item A graphics context (GC) allows requesting basic drawing and font rendering
  \item The server provides input events to concerned clients:
    \begin{itemize}
    \item Mouse movements relative to window coordinates
    \item Translated keycodes with a keymap, for local layout and combinations
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Xorg architecture}
  \begin{itemize}
  \item Xorg is divided between generic and hardware-specific parts
  \item Device-Independent-X (DIX) concerns:
    \begin{itemize}
    \item X11 protocol implementation, client coordination
    \item Software rendering fallback implementations
    \item Main event loop and tasks scheduling
    \end{itemize}
  \item Device-Dependent-X (DDX) concerns:
    \begin{itemize}
    \item Input drivers (\code{xf86-input-...}) to grab events from the kernel
    \item Video drivers (\code{xf86-video-...}) to provide mode setting and 2D acceleration
    \end{itemize}
  \item EXA provides a 2D acceleration architecture between DIX and DDX
    \begin{itemize}
    \item Efficient way for drivers to expose accelerated 2D operation primitives
    \item Replaced the XFree86 Acceleration Architecture (XAA)
    \item Reduces driver boilerplate
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Xorg drivers overview}
  \begin{itemize}
  \item Generic Xorg \textbf{input} drivers:
    \begin{itemize}
    \item \code{xf86-input-libinput}: using \code{libinput} to get input events
    \item \code{xf86-input-evdev}: using the \code{evdev} kernel interface directly (\textbf{deprecated})
    \end{itemize}
  \item Specific Xorg \textbf{input} drivers:
    \begin{itemize}
    \item \code{xf86-input-synaptics}: for laptop touchpads
    \item \code{xf86-input-wacom}: for Wacom drawing tablets
    \item Specific drivers are deprecated in favor of \code{xf86-input-libinput}
    \end{itemize}
  \item Common Xorg \textbf{display} drivers:
    \begin{itemize}
    \item \code{xf86-video-modesetting}: for \textbf{DRM KMS}, without acceleration
    \item \code{xf86-video-glamor}: for DRM KMS with \textbf{3D GPU-based acceleration}
    \item \code{xf86-video-fbdev}: for the \textbf{fbdev} interface, without acceleration (legacy)
    \end{itemize}
  \item Specific Xorg \textbf{display} drivers:
    \begin{itemize}
    \item \code{xf86-video-[intel,nouveau,amdgpu]}: profiting from 2D acceleration blocks
    \item Specific drivers are deprecated in favor of \code{xf86-video-glamor}\\
      \textit{the trend is to accelerate everything via 3D rendering instead of 2D accelerators}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Xorg extensions}
  \begin{itemize}
  \item X11 has evolved over time through \textbf{extensions} to its main protocol
  \item Provides updated interfaces to X clients, matching \textbf{new hardware features}
  \item \textbf{XKB} and \textbf{Xinput2} extensions:
    \begin{itemize}
    \item XKB was added to support complex keyboard layouts
    \item Xinput2 provides touchpad, touchscreen and multi-touch support
    \end{itemize}
  \item \textbf{XRandR} extension:
    \begin{itemize}
    \item Allows supporting and configuring (multiple) monitors
    \item Configuration and hotplugging is possible without server restart
    \end{itemize}
  \item \textbf{Composite} extension:
    \begin{itemize}
    \item Provides reliable buffering of window contents (less redraw)
    \item Exposes the window hierarchy and delegates window composition
    \item Enables compositing window managers
    \end{itemize}
  \item \textbf{Xv} extension:
    \begin{itemize}
    \item Video output mechanism to offload colorspace conversion (CSC) and scaling
    \item Involves buffer copies and lack synchronization (e.g. window move)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Xorg usage, integration and configuration}
  \begin{itemize}
  \item Xorg can be started with the \code{startx} command (wrapping \code{xinit})
    \begin{itemize}
    \item Executes server script from \code{/etc/X11/xinit/xserverrc} or \code{$HOME/.xserverrc}
    \item Executes client script from \code{/etc/X11/xinit/xinitrc} or \code{$HOME/.xinitrc}
    \end{itemize}
  \item An X \textbf{display manager} offers a login interface (e.g. KDM, LightDM)
    \begin{itemize}
    \item Runs under a Xorg server, with its own dedicated user
    \item Starts Xorg for authenticated users from session files in \code{/usr/share/xsessions/}
    \end{itemize}
  \item Used to require \textbf{running the server as root} to access graphics devices\\
    \textit{in particular, necessary to become DRM master}
    \begin{itemize}
    \item The \code{systemd-logind} login manager lifts the restriction
    \item Opens the DRM KMS fd privileged and passes it to Xorg via IPC
    \item Xorg can then drop privileges: details in the \code{Xorg.wrap} man page
    \end{itemize}
  \item Xorg is \textbf{configured} (both DIX and DDX) from \code{/etc/X11/xorg.conf}
  \item The \code{DISPLAY} environment variable indicates which server connection to use\\
    \begin{itemize}
    \item Already set for X client applications and inherited
    \item \code{export DISPLAY=:0} useful to launch programs from other TTYs
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Xorg code structure and walkthrough}
  \begin{itemize}
  \item Xorg source code available at: \url{https://gitlab.freedesktop.org/xorg/xserver}
  \item DDX components:
    \begin{itemize}
    \item Code specific to the Linux kernel under \code{hw/xfree86/os-support/linux/}
    \item Modesetting DRM KMS driver under: \code{hw/xfree86/drivers/modesetting/}
    \item fbdev core library under: \code{hw/xfree86/fbdevhw/}
    \item Glamor implementation under \code{glamor/}
    \end{itemize}
  \item DIX components:
    \begin{itemize}
    \item System-level helpers under \code{os/}
    \item Common framebuffer operations abstraction under \code{fb/}
    \item EXA abstraction under \code{exa/}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Xorg debug and documentation}
  \begin{itemize}
  \item Xorg has a \textbf{logging system} for all its components:
    \begin{itemize}
    \item Written to a file at \code{/var/log/Xorg.0.log}, \code{-logfile} option
    \item Verbosity can be set with the \code{-logverbose} option (log level)
    \item Printed on the standard output (\code{stdout})
    \end{itemize}
  \item Xorg can be bound to any VT with the \code{vt} command line option\\
    \textit{useful for remote debugging, with a virtual controlling terminal}
  \item \textbf{Community} contact:
    \begin{itemize}
    \item Mailing list: \code{xorg@lists.freedesktop.org}
    \item IRC channel: \code{#xorg} and \code{#xorg-devel} on the Freenode network
    \end{itemize}
  \item \textbf{Documentation} resources:
    \begin{itemize}
    \item Online wiki of the project: \url{https://www.x.org/wiki/Documentation/}
    \item Man pages: \code{X}, \code{Xserver}, \code{Xorg}, \code{xorg.conf}, \code{xinit} and more!
    \end{itemize}
  \end{itemize}
\end{frame}
