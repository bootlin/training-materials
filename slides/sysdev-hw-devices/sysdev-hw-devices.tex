\section{Accessing hardware devices}

\subsection{Kernel drivers}

\begin{frame}{Typical software stack for hardware access}
  \begin{columns}
    \column{0.6\textwidth}
    From the bottom to the top:
    \begin{itemize}
    \item A {\em bus controller driver} in the kernel drives an I2C,
      SPI, USB, PCI controller
    \item A {\em bus subsystem} provides an API for drivers to access
      a particular type of bus: I2C, SPI, PCI, USB, etc.
    \item A {\em device driver} in the kernel drives a particular
      device connected to a given bus
    \item A {\em driver subsystem} exposes features of certain class
      of devices, through a standard {\em kernel/user-space interface}
    \item An application can access the device through this standard {\em
        kernel/user-space interface} either directly or through a
      library.
    \end{itemize}
    \column{0.4\textwidth}
    \begin{center}
      \includegraphics[height=0.7\textheight]{slides/sysdev-hw-devices/kernel-driver-stack.pdf}
    \end{center}
  \end{columns}
\end{frame}

\begin{frame}{Stack illustrated with a GPIO expander}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/sysdev-hw-devices/kernel-driver-stack-gpio-i2c.pdf}
  \end{center}
\end{frame}

\begin{frame}{Standardized user-space interface}
  \begin{itemize}
  \item Strong advantage of kernel drivers: they expose a standard
    {\em kernel to user-space interface}
  \item All devices of the same class (e.g GPIO controllers) will
    expose the same {\em kernel to user-space interface}
  \item Applications don't have to know the details of the GPIO
    controller, they just need to know the standard user-space
    interface valid for all GPIO controllers
  \item Applications can use existing open-source libraries that
    leverage this standard user-space interface
  \item Such kernel drivers can also be used internally inside the
    kernel, for example if one driver needs to control a GPIO directly
    (reset signal, interrupt signal, etc.)
  \end{itemize}
\end{frame}

\begin{frame}{Numerous kernel subsystems for device classes}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{itemize}
    \item Networking stack for Ethernet, WiFi, CAN, 802.15.4, etc.
    \item GPIO
    \item Video4Linux for camera, video encoders/decoders
    \item DRM for display controllers, GPU
    \item ALSA for audio
    \item IIO for ADC, DAC, gyroscopes, sensors, and more
    \item MTD for flash memory
    \item PWM
    \end{itemize}
    \column{0.5\textwidth}
    \begin{itemize}
    \item Input for keyboard, mouse, touchscreen, joystick
    \item Watchdog
    \item RTC for real-time clocks
    \item remoteproc for auxiliary processors
    \item crypto for cryptographic accelerators
    \item hwmon for hardware monitoring sensors
    \item block layer for block storage
    \end{itemize}
  \end{columns}
  \begin{center}
    and many more
  \end{center}
\end{frame}

\begin{frame}{Accessing devices directly from user-space}
  \begin{itemize}
  \item Even though device drivers in the kernel are preferred, it is
    also possible to access devices directly from user-space
  \item Especially useful for very specific devices that do not fit in
    any existing kernel subsystems
  \item The kernel provides the following mechanisms, depending on the
    bus:
    \begin{itemize}
    \item I2C: \href{https://docs.kernel.org/i2c/dev-interface.html}{i2c-dev}
    \item SPI: \href{https://docs.kernel.org/spi/spidev.html}{spidev}
    \item Memory-mapped: \href{https://docs.kernel.org/driver-api/uio-howto.html}{UIO}
    \item USB: \code{/dev/bus/usb}, through \href{https://libusb.info/}{libusb}
    \item PCI: \href{https://docs.kernel.org/PCI/sysfs-pci.html}{sysfs entries for PCI}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Accessing devices directly from user-space: GPIO example}
  \begin{columns}
    \column{0.3\textwidth} {\small This diagram shows what's not
      recommended to do $\rightarrow$ for a GPIO controller, a kernel driver
      is preferred}
    \column{0.7\textwidth}
    \begin{center}
      \includegraphics[height=0.8\textheight]{slides/sysdev-hw-devices/kernel-driver-stack-gpio-i2c-direct-userspace.pdf}\\
    \end{center}
  \end{columns}
\end{frame}

\begin{frame}{What can go wrong with a user-space driver?}
  \begin{itemize}
  \item You write your GPIO driver in user-space: other kernel drivers
    cannot use GPIOs from this GPIO controller
    \begin{itemize}
    \item Other devices that use GPIO signals from this controller for reset, interrupt, etc. cannot control/configure those signals
    \item Your application is less portable: it will take many changes to support another type of GPIO controller.
    \end{itemize}
  \item You write your touchscreen driver in user-space: the standard
    Linux graphics stack components cannot use your touchscreen
  \item You write your network driver in user-space
    \begin{itemize}
    \item You can probably send/receive packets
    \item But you cannot leverage the Linux kernel networking stack
      for IP, TCP, UDP, etc.
    \item And none of the Linux networking applications can use your
      network device
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Upstream drivers vs. out-of-tree drivers}
  \begin{itemize}
  \item The {\em upstream} Linux kernel contains thousands of drivers
    \begin{itemize}
    \item This is the best place to look for drivers
    \item Drivers have been reviewed and approved by the community
    \item They comply with standard interfaces
    \end{itemize}
  \item Vendor kernels often include additional drivers, directly in
    the kernel tree
  \item Device vendors sometimes also provide {\em out of tree
      drivers}
    \begin{itemize}
    \item Their source code is provided separately from the Linux
      kernel tree
    \item Quality is often dubious
    \item Compatibility issues when updating to newer kernel releases
    \item Not always use standard user-space interfaces
    \item Example: \url{https://github.com/lwfinger/rtl8723ds}
    \item Avoid them when possible!
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Finding Linux kernel drivers}
  \begin{itemize}
  \item \code{grep} in the Linux kernel tree is your {\em best friend}
    \begin{itemize}
    \item For I2C, SPI and memory-mapped devices, matching of the
      driver is done based on the device name $\rightarrow$ {\em grep}
      for variants of the device name and vendor
    \item For USB, PCI, matching is done either on the vendor
      ID/product ID, or the class $\rightarrow$ {\em grep} for these
    \end{itemize}
  \item Driver file names are sometimes named in a ``generic'' way,
    not necessarily reflecting all devices they support.
    \begin{itemize}
    \item Example: \kfile{drivers/gpio/gpio-pca953x.c} supports much
      more than just PCA953x. See the
      \href{https://elixir.bootlin.com/linux/v5.19/source/drivers/gpio/gpio-pca953x.c\#L1221}{full
        list of devices} supported by this driver
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Finding Linux kernel drivers: an example}
  \begin{itemize}
  \item You have a
    \href{https://www.maximintegrated.com/en/products/interface/controllers-expanders/MAX7313.html}{Maxim
      Integrated MAX7313} GPIO expander on I2C
  \item Search in the Linux kernel
    \begin{block}{git grep -i max7313}
      {\tiny
\begin{verbatim}
drivers/gpio/gpio-pca953x.c:    { "max7313", 16 | PCA953X_TYPE | PCA_INT, },
drivers/gpio/gpio-pca953x.c:    { .compatible = "maxim,max7313", .data = OF_953X(16, PCA_INT), },
\end{verbatim}
      }
    \end{block}
  \item \kfile{drivers/gpio/gpio-pca953x.c} seems to support it
  \item Read \kfile{drivers/gpio/Makefile} to learn which kernel
    configuration option enables this driver
    \begin{block}{\kfile{drivers/gpio/Makefile}}
      {\tiny
\begin{verbatim}
obj-$(CONFIG_GPIO_PCA953X)              += gpio-pca953x.o
\end{verbatim}
      }
    \end{block}
  \item Conclusion: you need to enable \kconfig{CONFIG_GPIO_PCA953X} in
    your kernel configuration
  \end{itemize}
\end{frame}

\subsection{User-space interfaces to drivers}

\begin{frame}{User-space interfaces for hardware devices}

  For a high-level perspective: three main interfaces to access
  hardware devices exposed by the Linux kernel

  \begin{itemize}
  \item Device nodes in \code{/dev}
  \item Entries in the {\em sysfs} filesystem
  \item Network sockets and related APIs
  \end{itemize}
\end{frame}

\begin{frame}{Devices in {\em /dev/}}
  \begin{itemize}
  \item One of the kernel important roles is to {\bf allow applications
      to access hardware devices}
  \item In the Linux kernel, most devices are presented to user space
    applications through two different abstractions
    \begin{itemize}
    \item {\bf Character} device
    \item {\bf Block} device
    \end{itemize}
  \item Internally, the kernel identifies each device by a triplet of
    information
    \begin{itemize}
    \item {\bf Type} (character or block)
    \item {\bf Major} (typically the category of device)
    \item {\bf Minor} (typically the identifier of the device)
    \end{itemize}
  \item See \kfile{Documentation/admin-guide/devices.txt} for the
    official list of reserved type/major/minor numbers.
  \end{itemize}
\end{frame}

\begin{frame}{Block vs. character devices}
  \begin{itemize}
  \item Block devices
    \begin{itemize}
    \item A device composed of fixed-sized blocks, that can be read
      and written to store data
    \item Used for hard disks, USB keys, SD cards, etc.
    \end{itemize}
  \item Character devices
    \begin{itemize}
    \item Originally, an infinite stream of bytes, with no beginning,
      no end, no size. The pure example: a serial port.
    \item Used for serial ports, terminals, but also sound cards,
      video acquisition devices, frame buffers
    \item Most of the devices that are not block devices are
      represented as character devices by the Linux kernel
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Devices: everything is a file}
  \begin{itemize}
  \item A very important UNIX design decision was to represent most
    {\em system objects} as files
  \item It allows applications to manipulate all {\em system objects} with
    the normal file API (\code{open}, \code{read}, \code{write},
    \code{close}, etc.)
  \item So, devices had to be represented as files to the applications
  \item This is done through a special artifact called a {\bf device
      file}
  \item It is a special type of file, that associates a file name
    visible to user space applications to the triplet {\em (type,
      major, minor)} that the kernel understands
  \item All {\em device files} are by convention stored in the
    \code{/dev} directory
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Device files examples}

Example of device files in a Linux system

\small
\begin{verbatim}
$ ls -l /dev/ttyS0 /dev/tty1 /dev/sda /dev/sda1 /dev/sda2 /dev/sdc1 /dev/zero
brw-rw---- 1 root disk    8,  0 2011-05-27 08:56 /dev/sda
brw-rw---- 1 root disk    8,  1 2011-05-27 08:56 /dev/sda1
brw-rw---- 1 root disk    8,  2 2011-05-27 08:56 /dev/sda2
brw-rw---- 1 root disk    8, 32 2011-05-27 08:56 /dev/sdc
crw------- 1 root root    4,  1 2011-05-27 08:57 /dev/tty1
crw-rw---- 1 root dialout 4, 64 2011-05-27 08:56 /dev/ttyS0
crw-rw-rw- 1 root root    1,  5 2011-05-27 08:56 /dev/zero
\end{verbatim}
\normalsize

Example C code that uses the usual file API to write data to a serial port

\small
\begin{minted}{c}
int fd;
fd = open("/dev/ttyS0", O_RDWR);
write(fd, "Hello", 5);
close(fd);
\end{minted}
\end{frame}

\begin{frame}{Creating device files}
  \begin{itemize}
    \item Before Linux 2.6.32, on basic Linux systems,
    the device files had to be created manually using the
    \code{mknod} command
    \begin{itemize}
    \item \code{mknod /dev/<device> [c|b] major minor}
    \item Needs root privileges
    \item Coherency between device files and devices handled by the
      kernel was left to the system developer
    \end{itemize}
  \item The \code{devtmpfs} virtual filesystem can be mounted on
    \code{/dev} $\rightarrow$ the kernel automatically creates/removes
    device files
    \begin{itemize}
    \item \kconfig{CONFIG_DEVTMPFS_MOUNT} $\rightarrow$ asks the
      kernel to mount {\em devtmpfs} automatically at boot time
      (except when booting on an initramfs).
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Better handling of device files: {\em udev} and {\em mdev}}
  \begin{itemize}
  \item {\em devtmpfs} is great, but its capabilities are limited, so
    complementary solutions exist
  \item {\bf udev}
    \begin{itemize}
    \item daemon that receives events from the kernel about devices
      appearing/disappearing
    \item can create/remove device files (but that's done by
      {\em devtmpfs} now), adjust permission/ownership,
      load kernel modules automatically, create symbolic links to
      devices
    \item according to rules files in \code{/lib/udev/rules.d} and
      \code{/etc/udev/rules.d}
    \item used in almost all desktop Linux distributions
    \item \url{https://en.wikipedia.org/wiki/Udev}
    \end{itemize}
  \item {\bf mdev}
    \begin{itemize}
    \item lightweight implementation of {\em udev}, part of Busybox
    \item \url{https://wiki.gentoo.org/wiki/Mdev}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Examples of user-space interfaces in {\tt /dev}}
  \begin{itemize}
  \item Serial-ports: \code{/dev/ttyS*}, \code{/dev/ttyUSB*},
    \code{/dev/ttyACM*}, etc.
  \item GPIO controllers (modern interface): \code{/dev/gpiochipX}
  \item Block storage devices: \code{/dev/sd*}, \code{/dev/mmcblk*}, \code{/dev/nvme*}
  \item Flash storage devices: \code{/dev/mtd*}
  \item Display controllers and GPUs: \code{/dev/dri/*}
  \item Audio devices: \code{/dev/snd/*}
  \item Camera devices: \code{/dev/video*}
  \item Watchdog devices: \code{/dev/watchdog*}
  \item Input devices: \code{/dev/input/*}
  \item and many more...
  \end{itemize}
\end{frame}

\begin{frame}{{\em sysfs} filesystem}
  \begin{itemize}
  \item \code{block/}, symlinks to all block devices, in
    \code{/sys/devices}
  \item \code{bus/}, one sub-folder by type of bus
  \item \code{class/}, one sub-folder per class (category of devices):
    input, leds, pwm, etc.
  \item \code{dev/}
    \begin{itemize}
    \item \code{block/}, one symlink per block device, named after
      major/minor
    \item \code{char/}, one symlink per character device, named after
      major/minor
    \end{itemize}
  \item \code{devices/}, all devices in the system, organized in a
    slightly chaotic way, see \href{https://lwn.net/Articles/646617/}{this article}
  \item \code{firmware/}, representation of firmware data
    \begin{itemize}
    \item \code{devicetree/}, directory and file representation of
      Device Tree nodes and properties
    \end{itemize}
  \item \code{fs/}, properties related to filesystem drivers
  \item \code{kernel/}, properties related to various kernel subsystems
  \item \code{module/}, properties about kernel modules
  \item \code{power/}, power-management related properties
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{{\em sysfs} filesystem example}
  \begin{itemize}
  \item \code{/sys/bus/i2c/drivers}: all device drivers for devices
    connected on I2C busses
    \begin{block}{}
      {\tiny
\begin{verbatim}
[...]
edt_ft5x06
stpmic1
[...]
\end{verbatim}
      }
    \end{block}

  \item \code{/sys/bus/i2c/devices}: all devices in the system
    connected to I2C busses
    \begin{block}{}
      {\tiny
\begin{verbatim}
0-002a -> ../../../devices/platform/soc/40012000.i2c/i2c-0/0-002a
0-0039 -> ../../../devices/platform/soc/40012000.i2c/i2c-0/0-0039
0-004a -> ../../../devices/platform/soc/40012000.i2c/i2c-0/0-004a
1-0028 -> ../../../devices/platform/soc/5c002000.i2c/i2c-1/1-0028
1-0033 -> ../../../devices/platform/soc/5c002000.i2c/i2c-1/1-0033
i2c-0 -> ../../../devices/platform/soc/40012000.i2c/i2c-0
i2c-1 -> ../../../devices/platform/soc/5c002000.i2c/i2c-1
i2c-2 -> ../../../devices/platform/soc/40012000.i2c/i2c-0/i2c-2
\end{verbatim}
      }
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{{\em sysfs} filesystem example}
  \begin{block}{/sys/bus/i2c/devices/0-002a/}
    {\tiny
\begin{verbatim}
lrwxrwxrwx    driver -> ../../../../../../bus/i2c/drivers/edt_ft5x06
-rw-r--r--    gain
drwxr-xr-x    input
-r--r--r--    modalias
-r--r--r--    name
lrwxrwxrwx    of_node -> ../../../../../../firmware/devicetree/base/soc/i2c@40012000/touchscreen@2a
-rw-r--r--    offset
-rw-r--r--    offset_x
-rw-r--r--    offset_y
drwxr-xr-x    power
-rw-r--r--    report_rate
lrwxrwxrwx    subsystem -> ../../../../../../bus/i2c
-rw-r--r--    threshold
-rw-r--r--    uevent
\end{verbatim}
    }
  \end{block}

  \begin{itemize}
  \item \code{driver}, symlink to the driver directory in \code{/sys/bus/i2c/drivers}
  \item \code{of_node}, symlink to the directory for the Device Tree
    node describing this device
  \end{itemize}
\end{frame}

\begin{frame}{Example of driver interfaces in {\em sysfs}}
  \begin{itemize}
  \item All devices are visible in {\em sysfs}, whether they have an
    interface in \code{/dev} or not
    \begin{itemize}
    \item Usually \code{/dev} is to access the device
    \item \code{/sys} is more about properties of the devices
    \end{itemize}
  \item However, some devices only have a {\em sysfs} interface
    \begin{itemize}
    \item LED: \code{/sys/class/leds}, see \href{https://docs.kernel.org/leds/leds-class.html}{documentation}
    \item PWM: \code{/sys/class/pwm}, see \href{https://docs.kernel.org/driver-api/pwm.html\#using-pwms-with-the-sysfs-interface}{documentation}
    \item IIO: \code{/sys/bus/iio}, see \href{https://docs.kernel.org/driver-api/iio/index.html}{documentation}
    \item etc.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Accessing GPIOs}
  A class of devices worth mentioning is GPIOs ({\em General Purpose Input Output})
  \begin{itemize}
  \item The GPIOs can be accessed through a legacy interface in
        \code{/sys/class/gpios}
    \begin{itemize}
       \item You will find many instructions on the Internet about how
	     to drive GPIOs through this interface.
       \item However, this interface is deprecated and has multiple
             shortcomings:
             \begin{itemize}
		\item GPIOs remain exported if the process using them crashes
		\item Need to compute the GPIO numbers, such numbers are not stable
	     \end{itemize}
    \end{itemize}
  \item A new interface recommended: \href{https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/}{libgpiod}
    \begin{itemize}
	\item Based on \code{/dev/gpiochipx} character devices
        \item Implementing advanced features not possible with the legacy interface
	\item Of course, this is a C library
        \item But it also provides command line utilities:
              \code{gpiodetect}, \code{gpioset}, \code{gpioget}...
	\item The only constraint is to cross-compile them for your target
	      (the legacy interface could be used without any additional software).
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Other virtual filesystems}

  \begin{itemize}

  \item {\em debugfs}
    \begin{itemize}
    \item Conventionally mounted in \code{/sys/kernel/debug}
    \item Contains lots of debug information from the kernel,
      including device related
    \item \code{/sys/kernel/debug/pinctrl} for pin-mux debugging,
      \code{/sys/kernel/debug/gpio} for GPIO debugging,
      \code{/sys/kernel/debug/pwm} for PWM debugging, etc.
    \item \url{https://www.kernel.org/doc/html/latest/filesystems/debugfs.html}
    \end{itemize}
  \item {\em configfs}
    \begin{itemize}
    \item Conventionally mounted in \code{/sys/kernel/config}
    \item Allows to manage configuration of advanced kernel mechanisms
    \item Example: configuration of USB gadget functionalities
    \item \kfile{Documentation/filesystems/configfs.rst}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Using kernel modules}

\begin{frame}{Why kernel modules?}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item Primary reason: keep the kernel image minimal, and load
      drivers on-demand depending on the hardware detected
      \begin{itemize}
      \item Needed to create a generic kernel configuration that works
        on many platforms
      \item Used by all desktop/server Linux distributions
      \end{itemize}
    \item But also useful for
      \begin{itemize}
      \item Driver development: allows to modify, build and test a
        driver without rebooting
      \item Boot time reduction: allows to defer the initialization of
        a driver after user-space has started critical applications
      \end{itemize}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-hw-devices/modules-to-access-rootfs.pdf}
  \end{columns}
\end{frame}

\begin{frame}{Module installation and metadata}
  \begin{itemize}
  \item As discussed earlier, modules are installed in
    \code{/lib/modules/<kernel-version>/}
  \item Compiled kernel modules are stored in \code{.ko} ({\em Kernel Object}) files
  \item Metadata files:
    \begin{itemize}
    \item \code{modules.dep}
    \item \code{modules.alias}
    \item \code{modules.symbols}
    \item \code{modules.builtin}
    \end{itemize}
  \item Each file has a corresponding \code{.bin} version, which is an optimized version of the corresponding text file
  \end{itemize}
\end{frame}

\begin{frame}{Module dependencies: {\em modules.dep}}
  \begin{itemize}
  \item Some kernel modules can depend on other modules, based on the
    symbols (functions and data structures) that they use.
  \item Example: the \code{ubifs} module depends on the \code{ubi} and
    \code{mtd} modules.
    \begin{itemize}
    \item \code{mtd} and \code{ubi} need to be loaded before \code{ubifs}
    \end{itemize}
  \item These dependencies are described both in
    \code{/lib/modules/<kernel-version>/modules.dep} and in
    \code{/lib/modules/<kernel-version>/modules.dep.bin}
  \item Will be used by module loading tools.
  \end{itemize}
\end{frame}

\begin{frame}{Module alias: {\em modules.alias}}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/sysdev-hw-devices/module-alias-usage.pdf}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Module utilities: {\em modinfo}}
  \begin{itemize}
  \item \code{modinfo <module_name>}, for modules in \code{/lib/modules}
  \item \code{modinfo /path/to/module.ko}
  \end{itemize}

  \begin{block}{}
    {\tiny
\begin{verbatim}
# modinfo usb_storage
filename:       /lib/modules/5.18.13-200.fc36.x86_64/kernel/drivers/usb/storage/usb-storage.ko.xz
license:        GPL
description:    USB Mass Storage driver for Linux
author:         Matthew Dharm <mdharm-usb@one-eyed-alien.net>
alias:          usb:v*p*d*dc*dsc*dp*ic08isc06ip50in*
alias:          usb:v*p*d*dc*dsc*dp*ic08isc05ip50in*
alias:          usb:v*p*d*dc*dsc*dp*ic08isc04ip50in*
[...]
intree:         Y
name:           usb_storage
[...]
parm:           option_zero_cd:ZeroCD mode (1=Force Modem (default), 2=Allow CD-Rom (uint)
parm:           swi_tru_install:TRU-Install mode (1=Full Logic (def), 2=Force CD-Rom, 3=Force Modem) (uint)
parm:           delay_use:seconds to delay before using a new device (uint)
parm:           quirks:supplemental list of device IDs and their quirks (string)
\end{verbatim}
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{Module utilities: {\em lsmod}}

  \begin{itemize}
  \item Lists currently loaded kernel modules
  \item Includes
    \begin{itemize}
    \item The reference count: incremented when the module is used by
      another module or by a user-space process, prevents from unloading
      modules that are in-use
    \item Dependant modules: modules that depend on us
    \end{itemize}
  \item Information retrieved through \code{/proc/modules}
  \end{itemize}

  \begin{block}{}
    {\footnotesize
\begin{verbatim}
$ lsmod
Module                  Size  Used by
tun                    61440  2
tls                   118784  0
rfcomm                 90112  4
snd_seq_dummy          16384  0
snd_hrtimer            16384  1
wireguard              94208  0
curve25519_x86_64      36864  1 wireguard
libcurve25519_generic    49152  2 curve25519_x86_64,wireguard
ip6_udp_tunnel         16384  1 wireguard
\end{verbatim}
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{Module utilities: {\em insmod} and {\em rmmod}}
  \begin{itemize}
  \item Basic tools to:
    \begin{itemize}
    \item {\em load} a module: \code{insmod}
    \item {\em unload} a module: \code{rmmod}
    \end{itemize}
  \item Basic because:
    \begin{itemize}
    \item Need a full path to the module \code{.ko} file
    \item Do not handle module dependencies
    \end{itemize}
  \end{itemize}

  \begin{block}{}
    {\footnotesize
\begin{verbatim}
# insmod /lib/modules/`uname -r`/kernel/fs/fuse/cuse.ko.xz
# rmmod cuse
\end{verbatim}
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{Module utilities: {\em modprobe}}
  \begin{itemize}
  \item {\em modprobe} is the more advanced tool for loading/unloading
    modules
  \item Takes just a module name as argument: \code{modprobe <module-name>}
  \item Takes care of dependencies automatically, using the
    \code{modules.dep} file
  \item Supports removing modules using \code{modprobe -r}, including
    its no longer used dependencies
  \end{itemize}

  \begin{block}{}
    {\footnotesize
\begin{verbatim}
# modinfo fat_test | grep depends
depends:        kunit,fat
# lsmod | grep -E "^(kunit|fat|fat_test)"
fat                    86016  1 vfat
# modprobe fat_test
# lsmod | grep -E "^(kunit|fat|fat_test)"
fat_test               24576  0
kunit                  36864  1 fat_test
fat                    86016  2 fat_test,vfat
# sudo modprobe -r fat_test
# lsmod | grep -E "^(kunit|fat|fat_test)"
fat                    86016  1 vfat
\end{verbatim}
    }
  \end{block}
\end{frame}

\begin{frame}{Passing parameters to modules}
  \small
  \begin{itemize}
  \item Some modules have parameters to adjust their behavior
  \item Mostly for debugging/tweaking, as parameters are global to the
    module, not per-device managed by the module
  \item Through \code{insmod} or \code{modprobe}:\\
    \code{insmod ./usb-storage.ko delay_use=0}\\
    \code{modprobe usb-storage delay_use=0}
  \item \code{modprobe} supports configuration files: \code{/etc/modprobe.conf} or in any file in \code{/etc/modprobe.d/}:\\
    \code{options usb-storage delay_use=0}
  \item Through the kernel command line, when the module is built statically into the kernel:\\
    \code{usb-storage.delay_use=0}
    \begin{itemize}
    \item \code{usb-storage} is the {\em module name}
    \item \code{delay_use} is the {\em module parameter name}. It
      specifies a delay before accessing a USB storage device (useful for
      rotating devices).
    \item \code{0} is the {\em module parameter value}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Modules in {\em sysfs}}
  \begin{itemize}
  \item All modules are visible in {\em sysfs}, under \code{/sys/module/<name>}
  \item Lots of information available about each module
  \item For example, the \code{/sys/module/<name>/parameters}
    directory contains one file per module parameter
  \item Can read the current value of module parameters
  \item Some of them can even be changed at runtime (determined by the
    module code)
  \item Example:\\
    \code{echo 0 > /sys/module/usb_storage/parameters/delay_use}
  \end{itemize}
\end{frame}

\subsection{Describing non-discoverable hardware: Device Tree}

\begin{frame}{Describing non-discoverable hardware}
  \begin{columns}
    \column{0.3\textwidth}
    \begin{enumerate}
    \item<1> Directly in the {\bf OS/bootloader code}
    \item<2> Using {\bf ACPI} tables
    \item<3> Using a {\bf Device Tree}
    \end{enumerate}
    \column{0.7\textwidth}
    \only<1> {
      \begin{itemize}
      \item Using compiled data structures, typically in C
      \item How it was done on most embedded platforms in Linux, U-Boot.
      \item Considered not maintainable/sustainable on ARM32, which
        motivated the move to another solution.
      \end{itemize}
    }
    \only<2> {
      \begin{itemize}
      \item On {\em x86} systems, but also on a subset of ARM64 platforms
      \item Tables provided by the firmware
      \end{itemize}
    }
    \only<3> {
      \begin{itemize}
      \item Originates from {\bf OpenFirmware}, defined by Sun, used on
        SPARC and PowerPC
        \begin{itemize}
        \item That's why many Linux/U-Boot functions related to DT have
          a \code{of_} prefix
        \end{itemize}
      \item Now used by most embedded-oriented CPU architectures that run
        Linux: ARC, ARM64, RISC-V, ARM32, PowerPC, Xtensa, MIPS, etc.
      \item Writing/tweaking a DT is necessary when porting Linux to a
        new board, or when connecting additional peripherals
      \end{itemize}
    }
  \end{columns}
\end{frame}

\begin{frame}{Device Tree: from source to blob}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item A tree data structure describing the hardware is written by a
      developer in a {\bf Device Tree Source} file, \code{.dts}
    \item Processed by the {\bf Device Tree Compiler}, \code{dtc}
    \item Produces a more efficient representation: {\bf Device Tree
        Blob}, \code{.dtb}
    \item Additional C preprocessor pass
    \item \code{.dtb} $\rightarrow$ accurately describes the hardware platform in an {\bf OS-agnostic} way.
    \item \code{.dtb} $\approx$ few dozens of kilobytes
    \item DTB also called {\bf FDT}, {\em Flattened Device Tree}, once
      loaded into memory.
      \begin{itemize}
      \item \code{fdt} command in U-Boot
      \item \code{fdt_} APIs
      \end{itemize}
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[height=0.7\textheight]{slides/sysdev-hw-devices/dts-to-dtb.pdf}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{dtc example}
  \footnotesize
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{block}{}
\begin{verbatim}
$ cat foo.dts
/dts-v1/;

/ {
        welcome = <0xBADCAFE>;
        bootlin {
                webinar = "great";
                demo = <1>, <2>, <3>;
        };
};
\end{verbatim}
    \end{block}
    \pause
    \begin{block}{}
\begin{verbatim}
$ dtc -I dts -O dtb -o foo.dtb foo.dts
$ ls -l foo.dt*
-rw-r--r-- 1 thomas thomas 169 ... foo.dtb
-rw-r--r-- 1 thomas thomas 102 ... foo.dts
\end{verbatim}
    \end{block}
    \pause
    \column{0.5\textwidth}
    \begin{block}{}
\begin{verbatim}
$ dtc -I dtb -O dts foo.dtb
/dts-v1/;

/ {
        welcome = <0xbadcafe>;

        bootlin {
                webinar = "great";
                demo = <0x01 0x02 0x03>;
        };
};
\end{verbatim}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{Device Tree: using the blob}
  \begin{columns}
    \column{0.6\textwidth}
    \begin{itemize}
    \item Can be {\bf linked directly} inside a bootloader binary
      \begin{itemize}
      \item For example: U-Boot, Barebox
      \end{itemize}
    \item Can be {\bf passed} to the operating system by the bootloader
      \begin{itemize}
      \item Most common mechanism for the Linux kernel
      \item U-Boot: \code{boot[z,i,m] <kernel-addr> - <dtb-addr>}
      \item The bootloader can adjust the DTB before passing it to the
        kernel
      \end{itemize}
    \item The DTB parsing can be done using \code{libfdt}, or ad-hoc
      code
    \end{itemize}
    \column{0.4\textwidth}
    \includegraphics[height=0.8\textheight]{slides/sysdev-hw-devices/ram.pdf}
  \end{columns}
\end{frame}

\begin{frame}{Where are Device Tree Sources located?}
  \begin{itemize}
  \item Even though they are OS-agnostic, {\bf no central and
      OS-neutral} place to host Device Tree sources and share them
    between projects
    \begin{itemize}
    \item Often discussed, never done
    \end{itemize}
  \item In practice, the Linux kernel sources can be considered as the
    {\bf canonical location} for Device Tree Source files
    \begin{itemize}
    \item \code{arch/<ARCH>/boot/dts/<vendor>/}
    \item \code{arch/arm/boot/dts} (on ARM 32 architecture before Linux 6.5)
    \item $\approx$ 4500 Device Tree Source files (\code{.dts} and
          \code{.dtsi}) in Linux as of 6.0.
    \end{itemize}
  \item Duplicated/synced in various projects
    \begin{itemize}
    \item U-Boot, Barebox, TF-A
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Device Tree base syntax}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{itemize}
    \item Tree of {\bf nodes}
    \item Nodes with {\bf properties}
    \item Node $\approx$ a device or IP block
    \item Properties $\approx$ device characteristics
    \item Notion of {\bf cells} in property values
    \item Notion of {\bf phandle} to point to other nodes
    \item \code{dtc} only does syntax checking, no semantic validation
    \end{itemize}
    \column{0.5\textwidth}
    \begin{center}
      \includegraphics[height=0.6\textheight]{slides/sysdev-hw-devices/dt-basic-syntax.pdf}
    \end{center}
  \end{columns}
\end{frame}

\ifdefstring{\labboard}{stm32mp1}{
  \input{slides/sysdev-hw-devices/stm32mp1/sysdev-hw-devices-stm32mp1.tex}
}{}
\ifdefstring{\labboard}{imx93-frdm}{
  \input{slides/sysdev-hw-devices/imx93-frdm/sysdev-hw-devices-imx93-frdm.tex}
}{\input{slides/sysdev-hw-devices/stm32mp1/sysdev-hw-devices-stm32mp1.tex}}
