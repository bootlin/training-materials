\setbeamerfont{block title}{size=\scriptsize}

\section{Integrating new packages in Buildroot}

\begin{frame}{Why adding new packages in Buildroot?}
  \begin{itemize}
  \item A {\em package} in Buildroot-speak is the {\bf set of
      meta-information needed to automate the build process} of a
    certain component of a system.
  \item Can be used for open-source, third party proprietary
    components, or in-house components.
  \item Can be used for user space components (libraries and
    applications) but also for firmware, kernel drivers, bootloaders,
    etc.
  \item Do not confuse with the notion of {\em binary package} in a
    regular Linux distribution.
  \end{itemize}
\end{frame}

\begin{frame}{Basic elements of a Buildroot package}
  \begin{itemize}
  \item A directory, \code{package/foo}
  \item A \code{Config.in} file, written in {\em kconfig} language,
    describing the configuration options for the package.
  \item A \code{<pkg>.mk} file, written in {\em make}, describing where to
    fetch the source, how to build and install it, etc.
  \item An optional \code{<pkg>.hash} file, providing hashes to check
    the integrity of the downloaded tarballs and license files.
  \item Optionally, \code{.patch} files, that are applied on the
    package source code before building.
  \item Optionally, any additional file that might be useful for the
    package: init script, example configuration file, etc.
  \end{itemize}
\end{frame}

\subsection{{\tt Config.in} file}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: basics}
  \begin{itemize}
  \item Describes the configuration options for the package.
  \item Written in the {\em kconfig} language.
  \item One option is mandatory to enable/disable the package, it {\bf
      must} be named \code{BR2_PACKAGE_<PACKAGE>}.
    \begin{block}{}
      \scriptsize
\begin{verbatim}
config BR2_PACKAGE_VTUN
        bool "vtun"
	[...]
        help
          Tool for easily creating Virtual Tunnels over TCP/IP networks
          with traffic shaping, compression, and encryption.

          It supports IP, PPP, SLIP, Ethernet and other tunnel types.

          http://vtun.sourceforge.net/
\end{verbatim}
    \end{block}
  \item The main package option is a \code{bool} with the package name
    as the prompt. Will be visible in \code{menuconfig}.
  \item The help text give a quick description, and the homepage of
    the project.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: inclusion}
  \begin{itemize}
  \item The hierarchy of configuration options visible in
    \code{menuconfig} is built by reading the top-level
    \code{Config.in} file and the other \code{Config.in} file it
    includes.
  \item All \code{package/<pkg>/Config.in} files are included from
    \code{package/Config.in}.
  \item The location of a package in one of the package sub-menu is
    decided in this file.
  \end{itemize}
  \begin{block}{package/Config.in}
    \tiny
\begin{verbatim}
menu "Target packages"
menu "Audio and video applications"
        source "package/alsa-utils/Config.in"
        ...
endmenu
...
menu "Libraries"
menu "Audio/Sound"
        source "package/alsa-lib/Config.in"
        ...
endmenu
...
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}{\code{package/<pkg>/Config.in}: dependencies}
  \begin{itemize}
  \item {\em kconfig} allows to express dependencies using
    \code{select} or \code{depends on} statements
    \begin{itemize}
    \item \code{select} is an automatic dependency: if option {\em A}
      \code{select} option {\em B}, as soon as {\em A} is enabled,
      {\em B} will be enabled, and cannot be unselected.
    \item \code{depends on} is a user-assisted dependency: if option
      {\em A} \code{depends on} option {\em B}, {\em A} will only be
      visible when {\em B} is enabled.
    \end{itemize}
  \item Buildroot uses them as follows:
    \begin{itemize}
    \item \code{depends on} for architecture, toolchain feature, or
      {\em big} feature dependencies. E.g: package only available on
      x86, or only if wide char support is enabled, or depends on
      Python.
    \item \code{select} for enabling the necessary other packages
      needed to build the current package (libraries, etc.)
    \end{itemize}
  \item Such dependencies only ensure consistency at the configuration
    level. They {\bf do not guarantee build ordering}!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: dependency example}

  \begin{columns}
    \column[t]{0.6\textwidth}
    \begin{block}{btrfs-progs package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_BTRFS_PROGS
        bool "btrfs-progs"
        depends on BR2_USE_MMU # util-linux
        depends on BR2_TOOLCHAIN_HAS_THREADS
        select BR2_PACKAGE_LZO
        select BR2_PACKAGE_UTIL_LINUX
        select BR2_PACKAGE_UTIL_LINUX_LIBBLKID
        select BR2_PACKAGE_UTIL_LINUX_LIBUUID
        select BR2_PACKAGE_ZLIB
        help
          Btrfs filesystem utilities

          https://btrfs.wiki.kernel.org/index.php/Main_Page

comment "btrfs-progs needs a toolchain w/ threads"
        depends on BR2_USE_MMU
        depends on !BR2_TOOLCHAIN_HAS_THREADS
\end{verbatim}
  \end{block}
    \column[t]{0.4\textwidth}
    {\scriptsize
    \begin{itemize}
    \item \code{depends on BR2_USE_MMU}, because the package uses
      \code{fork()}. Note that there is no comment displayed about this
      dependency, because it's a limitation of the architecture.
    \item \code{depends on BR2_TOOLCHAIN_HAS_THREADS}, because the
      package requires thread support from the toolchain. There is an
      associated comment, because such support can be added to the
      toolchain.
    \item Multiple \code{select BR2_PACKAGE_*}, because the package
      needs numerous libraries.
    \end{itemize}}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Dependency propagation}

  \begin{itemize}
  \item A limitation of {\em kconfig} is that it doesn't propagate
    \code{depends on} dependencies accross \code{select} dependencies.
  \item Scenario: if package {\em A} has a \code{depends on FOO}, and
    package {\em B} has a \code{select A}, then package {\em B} must
    replicate the \code{depends on FOO}.
  \end{itemize}

  \begin{columns}
    \column{0.5\textwidth}
    \begin{block}{libglib2 package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_LIBGLIB2
        bool "libglib2"
        depends on BR2_USE_WCHAR # gettext
        depends on BR2_TOOLCHAIN_HAS_THREADS
        depends on BR2_USE_MMU # fork()
        select BR2_PACKAGE_HOST_QEMU if ...
        select BR2_PACKAGE_HOST_QEMU_LINUX_USER_MODE if ...
        select BR2_PACKAGE_LIBICONV if !BR2_ENABLE_LOCALE
        select BR2_PACKAGE_LIBFFI
        select BR2_PACKAGE_PCRE2
        select BR2_PACKAGE_ZLIB
[...]
\end{verbatim}
    \end{block}
    \column{0.5\textwidth}
    \begin{block}{neard package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_NEARD
        bool "neard"
        depends on BR2_USE_WCHAR # libglib2
        depends on BR2_TOOLCHAIN_HAS_THREADS # libnl, dbus, libglib2
        depends on BR2_USE_MMU # dbus, libglib2
        depends on !BR2_STATIC_LIBS # dlopen
        depends on BR2_TOOLCHAIN_HAS_SYNC_4
        select BR2_PACKAGE_DBUS
        select BR2_PACKAGE_LIBGLIB2
        select BR2_PACKAGE_LIBNL
[...]
\end{verbatim}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{\code{Config.in.host} for host packages?}
  \begin{itemize}
  \item Most of the packages in Buildroot are {\em target} packages,
    i.e. they are cross-compiled for the target architecture, and meant
    to be run on the target platform.
  \item Some packages have a {\em host} variant, built to be executed
    on the build machine. Such packages are needed for the build
    process of other packages.
  \item The majority of {\em host} packages are not visible in
    \code{menuconfig}: they are just dependencies of other packages,
    the user doesn't really need to know about them.
  \item A few of them are potentially directly useful to the user
    (flashing tools, etc.), and can be shown in the {\em Host
      utilities} section of \code{menuconfig}.
  \item In this case, the configuration option is in a
    \code{Config.in.host} file, included from
    \code{package/Config.in.host}, and the option must be named
    \code{BR2_PACKAGE_HOST_<PACKAGE>}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{Config.in.host} example}
  \begin{block}{package/Config.in.host}
    \tiny
\begin{verbatim}
menu "Host utilities"

        source "package/genimage/Config.in.host"
        source "package/lpc3250loader/Config.in.host"
        source "package/openocd/Config.in.host"
        source "package/qemu/Config.in.host"

endmenu
\end{verbatim}
  \end{block}

  \begin{block}{package/openocd/Config.in.host}
    \tiny
\begin{verbatim}
config BR2_PACKAGE_HOST_OPENOCD
        bool "host openocd"
        depends on BR2_HOST_GCC_AT_LEAST_4_9 # host-libusb
        help
          OpenOCD - Open On-Chip Debugger

          http://openocd.org
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\code{Config.in} sub-options}
  \begin{columns}
    \column{0.4\textwidth}
    \begin{itemize}
    \item Additional sub-options can be defined to further configure
      the package, to enable or disable extra features.
    \item The value of such options can then be fetched from the package
      \code{.mk} file to adjust the build accordingly.
    \item Run-time configuration does not belong to \code{Config.in}.
    \end{itemize}
    \column{0.6\textwidth}
    \begin{block}{package/pppd/Config.in}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_PPPD
        bool "pppd"
        depends on !BR2_STATIC_LIBS
        depends on BR2_USE_MMU
        ...

if BR2_PACKAGE_PPPD

config BR2_PACKAGE_PPPD_FILTER
        bool "filtering"
        select BR2_PACKAGE_LIBPCAP
        help
          Packet filtering abilities for pppd. If enabled,
          the pppd active-filter and pass-filter options
          are available.

endif
\end{verbatim}
    \end{block}
  \end{columns}
\end{frame}

\subsection{Package infrastructures}

\begin{frame}{Package infrastructures: what is it?}
  \begin{itemize}
  \item Each software component to be built by Buildroot comes with
    its own {\em build system}.
  \item Buildroot does not re-invent the build system of each
    component, it simply uses it.
  \item Numerous build systems available: hand-written Makefiles or
    shell scripts, {\em autotools}, {\em Meson}, {\em CMake} and also
    some specific to languages: Python, Perl, Lua, Erlang, etc.
  \item In order to avoid duplicating code, Buildroot has {\em package
      infrastructures} for well-known build systems.
  \item And a generic package infrastructure for software components
    with non-standard build systems.
  \end{itemize}
\end{frame}

\begin{frame}{Package infrastructures}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/buildroot-new-packages/package-infrastructures.pdf}
  \end{center}
\end{frame}

\begin{frame}{\code{generic-package} infrastructure}
  \begin{itemize}
  \item To be used for software components having non-standard build
    systems.
  \item Implements a default behavior for the downloading, extracting
    and patching steps of the package build process.
  \item Implements init script installation, legal information
    collection, etc.
  \item Leaves to the package developer the responsibility of
    describing what should be done for the configuration, building and
    installation steps.
  \end{itemize}
\end{frame}

\begin{frame}{\code{generic-package}: steps}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/buildroot-new-packages/generic-package.pdf}
  \end{center}
\end{frame}

\begin{frame}{Other package infrastructures}
  \begin{itemize}
  \item The other package infrastructures are meant to be used when
    the software component uses a well-known build system.
  \item They {\em inherit} all the behavior of the
    \code{generic-package} infrastructure: downloading, extracting,
    patching, etc.
  \item And in addition to that, they typically implement a default
    behavior for the configuration, compilation and installation
    steps.
  \item For example, \code{autotools-package} will implement the
    configuration step as a call to the \code{./configure} script with
    the right arguments.
  \item \code{pkg-kconfig} is an exception, it only provides some
    helpers for packages using Kconfig, but does not implement the
    configure, build and installation steps.
  \end{itemize}
\end{frame}

\subsection{{\tt .mk} file for {\tt generic-package}}

\begin{frame}[fragile]{The \code{<pkg>.mk} file}
  \begin{itemize}
  \item The \code{.mk} file of a package does not look like a normal
    Makefile.
  \item It is a succession of variable definitions, which must be
    prefixed by the uppercase package name.
    \begin{itemize}
    \item \code{FOOBAR_SITE = https://foobar.com/downloads/}
    \item
\begin{minted}{make}
define FOOBAR_BUILD_CMDS
       $(MAKE) -C $(@D)
endef
\end{minted}
    \end{itemize}
  \item And ends with a call to the desired package infrastructure
    macro.
    \begin{itemize}
    \item \code{$(eval $(generic-package))}
    \item \code{$(eval $(autotools-package))}
    \item \code{$(eval $(host-autotools-package))}
    \end{itemize}
  \item The variables tell the package infrastructure what to do for
    this specific package.
  \end{itemize}
\end{frame}

\begin{frame}{Naming conventions}

  \begin{itemize}
  \item The Buildroot package infrastructures make a number of
    assumption on variables and files naming.
  \item The following {\bf must} match to allow the package
    infrastructure to work for a given package:
    \begin{itemize}
    \item The directory where the package description is located {\bf
        must} be \code{package/<pkg>/}, where \code{<pkg>} is the
      lowercase name of the package.
    \item The \code{Config.in} option enabling the package {\bf must}
      be named \code{BR2_PACKAGE_<PKG>}, where \code{<PKG>} is the
      uppercase name of the package.
    \item The variables in the \code{.mk} file {\bf must} be prefixed
      with \code{<PKG>_}, where \code{<PKG>} is the uppercase name of
      the package.
    \end{itemize}
  \item Note: a \code{-} in the lower-case package name is translated
    to \code{_} in the upper-case package name.
  \end{itemize}
\end{frame}

\begin{frame}{Naming conventions: global namespace}
  \begin{itemize}
  \item The package infrastructure expects all variables it uses to be
    prefixed by the uppercase package name.
  \item If your package needs to define additional private variables
    not used by the package infrastructure, they {\bf should} also be
    prefixed by the {\bf uppercase package name}.
  \item The {\bf namespace of variables is global} in Buildroot!
    \begin{itemize}
    \item If two packages created a variable named \code{BUILD_TYPE},
      it will silently conflict.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Behind the scenes}
  \begin{itemize}
  \item Behind the scenes, \code{$(eval $(generic-package))}:
    \begin{itemize}
    \item is a {\em make} macro that is expanded
    \item infers the name of the current package by looking at the
      directory name: \code{package/<pkg>/<pkg>.mk}: \code{<pkg>} is
      the package name
    \item will use all the variables prefixed by \code{<PKG>_}
    \item and expand to a set of {\em make} rules and variable
      definitions that describe what should be done for each step of
      the package build process
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{{\tt .mk} file: accessing the configuration}

  \begin{itemize}
  \item The Buildroot \code{.config} file is a succession of lines
    \code{name = value}
    \begin{itemize}
    \item This file is valid {\em make} syntax!
    \end{itemize}
  \item The main Buildroot \code{Makefile} simply includes it, which
    turns every Buildroot configuration option into a {\em make}
    variable.
  \item From a package \code{.mk} file, one can directly use such
    variables:
    \begin{block}{}
    \begin{minted}[fontsize=\tiny]{make}
ifeq ($(BR2_PACKAGE_LIBCURL),y)
...
endif

FOO_DEPENDENCIES += $(if $(BR2_PACKAGE_TIFF),tiff)
\end{minted}
\end{block}

\item Hint: use the {\em make} \code{qstrip} function to remove double
  quotes on string options:
\begin{block}{}
  \begin{minted}[fontsize=\tiny]{make}
NODEJS_MODULES_LIST = $(call qstrip,$(BR2_PACKAGE_NODEJS_MODULES_ADDITIONAL))
  \end{minted}
\end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Download related variables}
  \begin{itemize}
  \item \code{<pkg>_SITE}, {\bf download location}
    \begin{itemize}
    \item HTTP(S) or FTP URL where a tarball can be found, or the address
      of a version control repository.
    \item \code{CAIRO_SITE = http://cairographics.org/releases}
    \item \code{FMC_SITE = git://git.freescale.com/ppc/sdk/fmc.git}
    \end{itemize}
  \item \code{<pkg>_VERSION}, {\bf version of the
    package}
  \begin{itemize}
    \item version of a tarball, or a commit, revision or tag for
      version control systems
    \item \code{CAIRO_VERSION = 1.14.2}
    \item \code{FMC_VERSION = fsl-sdk-v1.5-rc3}
    \end{itemize}
  \item \code{<pkg>_SOURCE}, {\bf file name} of the tarball
    \begin{itemize}
    \item The full URL of the downloaded tarball is
      \code{$(<pkg>_SITE)/$(<pkg>_SOURCE)}
    \item When not specified, defaults to
      \code{<pkg>-$(<pkg>_VERSION).tar.gz}
    \item \code{CAIRO_SOURCE = cairo-$(CAIRO_VERSION).tar.xz}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Available download methods}
  \begin{itemize}
  \item Buildroot can fetch the source code using different methods:
    \begin{itemize}
    \item \code{wget}, for FTP/HTTP downloads
    \item \code{scp}, to fetch the tarball using SSH/SCP
    \item \code{svn}, for Subversion
    \item \code{cvs}, for CVS
    \item \code{git}, for Git
    \item \code{hg}, for Mercurial
    \item \code{bzr}, for Bazaar
    \item \code{file}, for a local tarball
    \item \code{local}, for a local directory
    \end{itemize}
  \item In most cases, the fetching method is guessed by Buildroot
    using the \code{<pkg>_SITE} variable.
  \item Exceptions:
    \begin{itemize}
    \item Git, Subversion or Mercurial repositories accessed over
      HTTP or SSH.
    \item \code{file} and \code{local} methods
    \end{itemize}
  \item In such cases, use \code{<pkg>_SITE_METHOD} explicitly.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Download methods examples}

  \begin{itemize}
  \item Subversion repository accessed over HTTP:
    \begin{block}{}
      \begin{minted}{make}
LIBXMLRPC_VERSION = r3176
LIBXMLRPC_SITE = https://svn.code.sf.net/p/xmlrpc-c/code/advanced
LIBXMLRPC_SITE_METHOD = svn
      \end{minted}
    \end{block}
  \item Git repository accessed over HTTP:
    \begin{block}{}
      \begin{minted}{make}
LIBUCI_VERSION = 4b3db1179747b6a6779029407984bacef851325c
LIBUCI_SITE = https://git.openwrt.org/project/uci.git
LIBUCI_SITE_METHOD = git
      \end{minted}
    \end{block}
  \item Source code available in a local directory:
    \begin{block}{}
      \begin{minted}{make}
MYAPP_SITE = $(TOPDIR)/../apps/myapp
MYAPP_SITE_METHOD = local
      \end{minted}
    \end{block}
    \begin{itemize}
    \item The "{\em download}" will consist in copying the source code
      from the designated directory to the Buildroot per-package build
      directory.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Downloading more elements}
  \begin{itemize}
  \item \code{<pkg>_PATCH}, a list of patches to download and apply
    before building the package. They are automatically applied by the
    package infrastructure.
  \item \code{<pkg>_EXTRA_DOWNLOADS}, a list of additional files to
    download together with the package source code. It is up to the
    package \code{.mk} file to do something with them.
  \item Two options:
    \begin{itemize}
    \item Just a file name: assumed to be relative to \code{<pkg>_SITE}.
    \item A full URL: downloaded over HTTP, FTP.
    \end{itemize}
  \item Examples:
    \begin{block}{sysvinit.mk}
      \begin{minted}[fontsize=\tiny]{make}
UNZIP_PATCH = unzip_$(UNZIP_VERSION)-27.debian.tar.xz
      \end{minted}
    \end{block}

    \begin{block}{perl.mk}
      \begin{minted}[fontsize=\tiny]{make}
PERL_CROSS_SITE = http://raw.github.com/arsv/perl-cross/releases
PERL_CROSS_SOURCE = perl-$(PERL_CROSS_BASE_VERSION)-cross-$(PERL_CROSS_VERSION).tar.gz
PERL_EXTRA_DOWNLOADS = $(PERL_CROSS_SITE)/$(PERL_CROSS_SOURCE)
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Hash file}

  \begin{itemize}

  \item In order to validate the integrity of downloaded files and
    license files, and make sure the user uses the version which was
    tested by the Buildroot developers, {\em cryptographic hashes} are
    used

  \item Each package may contain a file named \code{<package>.hash},
    which gives the hashes of the files downloaded by the package.

  \item When present, the hashes for {\bf all} files downloaded by the
    package must be documented.

  \item The {\em hash file} can also contain the hashes for the
    license files listed in \code{<pkg>_LICENSE_FILES}. This allows to
    detect changes in the license files.

  \item The syntax of the file is:
    \begin{block}{}
      {\tiny
\begin{verbatim}
<hashtype>  <hash>  <file>
\end{verbatim}
      }
    \end{block}
    Note: the separator between fields is 2 spaces.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Hash file examples}
  \begin{block}{package/perl/perl.hash}
    {\tiny
\begin{verbatim}
# Hashes from: https://www.cpan.org/src/5.0/perl-5.40.1.tar.xz.{md5,sha1,sha256}.txt
md5  bab3547a5cdf2302ee0396419d74a42e  perl-5.40.1.tar.xz
sha1  4ffe5246c791df884363aed05ba81ba41cb02084  perl-5.40.1.tar.xz
sha256  dfa20c2eef2b4af133525610bbb65dd13777ecf998c9c5b1ccf0d308e732ee3f  perl-5.40.1.tar.xz

# Hash from: https://github.com/arsv/perl-cross/releases/download/1.6.1/perl-cross-1.6.1.hash
sha256  b5f4b4457bbd7be37adac8ee423beedbcdba8963a85f79770f5e701dabc5550f  perl-cross-1.6.1.tar.gz

# Locally calculated
sha256  dd90d4f42e4dcadf5a7c09eea0189d93c7b37ae560c91f0f6d5233ed3b9292a2  Artistic
sha256  d77d235e41d54594865151f4751e835c5a82322b0e87ace266567c3391a4b912  Copying
sha256  af805523b88a8ebb60afc009caaf247a498208502f7b8b3d9d3e329fcfb1dc3b  README
\end{verbatim}
    }
  \end{block}

  \begin{block}{package/ipset/ipset.hash}
    {\tiny
\begin{verbatim}
# From https://ipset.netfilter.org/ipset-7.16.tar.bz2.sha512sum.txt
sha512  e69ddee956f0922c8e08e7e5d358d6b5b24178a9f08151b20957cc3465baaba9ecd6aa938ae157f2cd286ccd7f0b7a279cfd89cec2393a00b43e4d945c275307  ipset-7.16.tar.bz2
# Locally calculated
sha256  231f7edcc7352d7734a96eef0b8030f77982678c516876fcb81e25b32d68564c  COPYING
\end{verbatim}
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{Describing dependencies}
  \begin{itemize}
  \item Dependencies expressed in \code{Config.in} do not enforce
    build order.
  \item The \code{<pkg>_DEPENDENCIES} variable is used to describe the
    dependencies of the current package.
  \item Packages listed in \code{<pkg>_DEPENDENCIES} are guaranteed to
    be built before the {\em configure} step of the current package
    starts.
  \item It can contain both target and host packages.
  \item It can be appended conditionally with additional dependencies.
  \end{itemize}

  \begin{block}{python.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
PYTHON_DEPENDENCIES = host-python libffi

ifeq ($(BR2_PACKAGE_PYTHON_READLINE),y)
PYTHON_DEPENDENCIES += readline
endif
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}{Mandatory vs. optional dependencies}

  \begin{itemize}
  \item Very often, software components have some {\bf mandatory
      dependencies} and some {\bf optional dependencies}, only needed
    for optional features.
  \item Handling mandatory dependencies in Buildroot consists in:
    \begin{itemize}
    \item Using a \code{select} or \code{depends on} on the main
      package option in \code{Config.in}
    \item Adding the dependency in \code{<pkg>_DEPENDENCIES}
    \end{itemize}
  \item For optional dependencies, there are two possibilities:
    \begin{itemize}
    \item Handle it automatically: in the \code{.mk} file, if the
      optional dependency is available, use it.
    \item Handle it explicitly: add a package sub-option in the
      \code{Config.in} file.
    \end{itemize}
  \item {\em Automatic} handling is usually preferred as it reduces
    the number of \code{Config.in} options, but it makes the possible
    dependency less visible to the user.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt ntp} example}

  \begin{itemize}
  \item Mandatory dependency: \code{libevent}
  \item Optional dependency handled automatically: \code{openssl}
  \end{itemize}

\begin{block}{package/ntp/Config.in}
{\scriptsize
\begin{verbatim}
config BR2_PACKAGE_NTP
        bool "ntp"
        select BR2_PACKAGE_LIBEVENT
[...]
\end{verbatim}}
\end{block}

\begin{block}{package/ntp/ntp.mk}
\begin{minted}[fontsize=\scriptsize]{make}
[...]
NTP_DEPENDENCIES = host-pkgconf libevent
[...]
ifeq ($(BR2_PACKAGE_OPENSSL),y)
NTP_CONF_OPTS += --with-crypto --enable-openssl-random
NTP_DEPENDENCIES += openssl
else
NTP_CONF_OPTS += --without-crypto --disable-openssl-random
endif
[...]
\end{minted}
\end{block}

\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt mpd} example (1/2)}

\begin{block}{package/mpd/Config.in}
{\scriptsize
\begin{verbatim}
menuconfig BR2_PACKAGE_MPD
        bool "mpd"
        depends on BR2_INSTALL_LIBSTDCPP
[...]
        select BR2_PACKAGE_BOOST
        select BR2_PACKAGE_LIBGLIB2
        select BR2_PACKAGE_LIBICONV if !BR2_ENABLE_LOCALE
[...]

config BR2_PACKAGE_MPD_FLAC
        bool "flac"
        select BR2_PACKAGE_FLAC
        help
          Enable flac input/streaming support.
          Select this if you want to play back FLAC files.

\end{verbatim}}
\end{block}

\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt mpd} example (2/2)}

\begin{block}{package/mpd/mpd.mk}
\begin{minted}[fontsize=\scriptsize]{make}
MPD_DEPENDENCIES = host-pkgconf boost libglib2

[...]

ifeq ($(BR2_PACKAGE_MPD_FLAC),y)
MPD_DEPENDENCIES += flac
MPD_CONF_OPTS += --enable-flac
else
MPD_CONF_OPTS += --disable-flac
endif
\end{minted}
\end{block}

\end{frame}


\begin{frame}{Defining where to install (1)}
  \begin{itemize}
  \item Target packages can install files to different locations:
    \begin{itemize}
    \item To the {\em target} directory, \code{$(TARGET_DIR)}, which is
      what will be the target root filesystem.
    \item To the {\em staging} directory, \code{$(STAGING_DIR)}, which
      is the compiler {\em sysroot}
    \item To the {\em images} directory, \code{$(BINARIES_DIR)}, which
      is where final images are located.
    \end{itemize}
  \item There are three corresponding variables, to define whether or
    not the package will install something to one of these locations:
    \begin{itemize}
    \item \code{<pkg>_INSTALL_TARGET}, defaults to \code{YES}. If
      \code{YES}, then \code{<pkg>_INSTALL_TARGET_CMDS} will be
      called.
    \item \code{<pkg>_INSTALL_STAGING}, defaults to \code{NO}. If
      \code{YES}, then \code{<pkg>_INSTALL_STAGING_CMDS} will be
      called.
    \item \code{<pkg>_INSTALL_IMAGES}, defaults to \code{NO}. If
      \code{YES}, then \code{<pkg>_INSTALL_IMAGES_CMDS} will be
      called.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Defining where to install (2)}

  \begin{itemize}
  \item A package for an application:
    \begin{itemize}
    \item installs to \code{$(TARGET_DIR)} only
    \item \code{<pkg>_INSTALL_TARGET} defaults to \code{YES}, so there
      is nothing to do
    \end{itemize}
  \item A package for a shared library:
    \begin{itemize}
    \item installs to both \code{$(TARGET_DIR)} and \code{$(STAGING_DIR)}
    \item must set \code{<pkg>_INSTALL_STAGING = YES}
    \end{itemize}
  \item A package for a pure header-based library, or a static-only
    library:
    \begin{itemize}
    \item installs only to \code{$(STAGING_DIR)}
    \item must set \code{<pkg>_INSTALL_TARGET = NO} and
    \code{<pkg>_INSTALL_STAGING = YES}
  \end{itemize}
  \item A package installing a bootloader or kernel image:
    \begin{itemize}
    \item installs to \code{$(BINARIES_DIR)}
    \item must set \code{<pkg>_INSTALL_IMAGES = YES}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Defining where to install (3)}
  \begin{block}{libyaml.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
LIBYAML_INSTALL_STAGING = YES
    \end{minted}
  \end{block}

  \begin{block}{eigen.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
EIGEN_INSTALL_STAGING = YES
EIGEN_INSTALL_TARGET = NO
    \end{minted}
  \end{block}

  \begin{block}{linux.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
LINUX_INSTALL_IMAGES = YES
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}{Describing actions for \code{generic-package}}
  \begin{itemize}
  \item In a package using \code{generic-package}, only the download,
    extract and patch steps are implemented by the package
    infrastructure.
  \item The other steps should be described by the package \code{.mk}
    file:
    \begin{itemize}
    \item \code{<pkg>_CONFIGURE_CMDS}, always called
    \item \code{<pkg>_BUILD_CMDS}, always called
    \item \code{<pkg>_INSTALL_TARGET_CMDS}, called when
      \code{<pkg>_INSTALL_TARGET = YES}, for target packages
    \item \code{<pkg>_INSTALL_STAGING_CMDS}, called when
      \code{<pkg>_INSTALL_STAGING = YES}, for target packages
    \item \code{<pkg>_INSTALL_IMAGES_CMDS}, called when
      \code{<pkg>_INSTALL_IMAGES = YES}, for target packages
    \item \code{<pkg>_INSTALL_CMDS}, always called for host packages
    \end{itemize}
  \item Packages are free to not implement any of these variables:
    they are all optional.
  \end{itemize}
\end{frame}

\begin{frame}{Describing actions: useful variables}
  Inside an action block, the following variables are often useful:
  \begin{itemize}
  \item \code{$(@D)} is the source directory of the package
  \item \code{$(MAKE)} to call \code{make}
  \item \code{$(MAKE1)} when the package doesn't build properly in
    parallel mode
  \item \code{$(TARGET_MAKE_ENV)} and \code{$(HOST_MAKE_ENV)}, to pass
    in the \code{$(MAKE)} environment to ensure the \code{PATH} is
    correct
  \item \code{$(TARGET_CONFIGURE_OPTS)} and
    \code{$(HOST_CONFIGURE_OPTS)} to pass \code{CC}, \code{LD},
    \code{CFLAGS}, etc.
  \item \code{$(TARGET_DIR)}, \code{$(STAGING_DIR)},
    \code{$(BINARIES_DIR)} and \code{$(HOST_DIR)}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Describing actions: {\tt iodine.mk} example}
  \begin{block}{}
    \begin{minted}[fontsize=\scriptsize]{make}
IODINE_VERSION = 0.7.0
IODINE_SITE = http://code.kryo.se/iodine
IODINE_DEPENDENCIES = zlib
IODINE_LICENSE = MIT
IODINE_LICENSE_FILES = README

IODINE_CFLAGS = $(TARGET_CFLAGS)
[...]

define IODINE_BUILD_CMDS
        $(TARGET_CONFIGURE_OPTS) CFLAGS="$(IODINE_CFLAGS)" \
                $(MAKE) ARCH=$(BR2_ARCH) -C $(@D)
endef

define IODINE_INSTALL_TARGET_CMDS
        $(TARGET_CONFIGURE_OPTS) $(MAKE) -C $(@D) install DESTDIR="$(TARGET_DIR)" prefix=/usr
endef

$(eval $(generic-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Describing actions: {\tt libzlib.mk} example}
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{make}
LIBZLIB_VERSION = 1.2.11
LIBZLIB_SOURCE = zlib-$(LIBZLIB_VERSION).tar.xz
LIBZLIB_SITE = http://www.zlib.net
LIBZLIB_INSTALL_STAGING = YES

define LIBZLIB_CONFIGURE_CMDS
        (cd $(@D); rm -rf config.cache; \
                $(TARGET_CONFIGURE_ARGS) \
                $(TARGET_CONFIGURE_OPTS) \
                CFLAGS="$(TARGET_CFLAGS) $(LIBZLIB_PIC)" \
                ./configure \
                $(LIBZLIB_SHARED) \
                --prefix=/usr \
        )
endef

define LIBZLIB_BUILD_CMDS
        $(TARGET_MAKE_ENV) $(MAKE1) -C $(@D)
endef

define LIBZLIB_INSTALL_STAGING_CMDS
        $(TARGET_MAKE_ENV) $(MAKE1) -C $(@D) DESTDIR=$(STAGING_DIR) LDCONFIG=true install
endef

define LIBZLIB_INSTALL_TARGET_CMDS
        $(TARGET_MAKE_ENV) $(MAKE1) -C $(@D) DESTDIR=$(TARGET_DIR) LDCONFIG=true install
endef

$(eval $(generic-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}{List of package infrastructures (1/2)}
  \begin{itemize}
  \item \code{generic-package}, for packages not using a well-known
    build system. Already covered.
  \item \code{autotools-package}, for {\em autotools} based packages,
    covered later.
  \item \code{python-package}, for {\em distutils} and {\em
      setuptools} based Python packages
  \item \code{perl-package}, for {\em Perl} packages
  \item \code{luarocks-package}, for Lua packages hosted on
    \code{luarocks.org}
  \item \code{cmake-package}, for {\em CMake} based packages
  \item \code{waf-package}, for {\em Waf} based packages
  \item \code{qmake-package}, for {\em QMake} based packages
  \end{itemize}
\end{frame}

\begin{frame}{List of package infrastructures (2/2)}
  \begin{itemize}
  \item \code{golang-package}, for packages written in Go
  \item \code{meson-package}, for packages using the Meson build
    system
  \item \code{cargo-package}, for packages written in Rust
  \item \code{kconfig-package}, to be used in conjunction with
    \code{generic-package}, for packages that use the {\em kconfig}
    configuration system
  \item \code{kernel-module-package}, to be used in conjunction with
    another package infrastructure, for packages that build kernel
    modules
  \item \code{rebar-package} for {\em Erlang} packages that use the
    {\em rebar} build system
  \item \code{virtual-package} for {\em virtual} packages, covered
    later.
  \end{itemize}
\end{frame}

\subsection{{\tt autotools-package} infrastructure}

\begin{frame}{The \code{autotools-package} infrastructure: basics}

  \begin{itemize}
  \item The \code{autotools-package} infrastructure inherits from
    \code{generic-package} and is specialized to handle {\em
      autotools} based packages.
  \item It provides a default implementation of:
    \begin{itemize}
    \item \code{<pkg>_CONFIGURE_CMDS}. Calls the \code{./configure}
      script with appropriate environment variables and arguments.
    \item \code{<pkg>_BUILD_CMDS}. Calls \code{make}.
    \item \code{<pkg>_INSTALL_TARGET_CMDS},
      \code{<pkg>_INSTALL_STAGING_CMDS} and
      \code{<pkg>_INSTALL_CMDS}. Call \code{make install} with the
      appropriate \code{DESTDIR}.
    \end{itemize}
  \item A normal {\em autotools} based package therefore does not need
    to describe any action: only metadata about the package.
  \end{itemize}
\end{frame}

\begin{frame}{The \code{autotools-package}: steps}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/buildroot-new-packages/autotools-package.pdf}
  \end{center}
\end{frame}

\begin{frame}{The \code{autotools-package} infrastructure: variables}
  \begin{itemize}
  \item It provides additional variables that can be defined by the
    package:
    \begin{itemize}
    \item \code{<pkg>_CONF_ENV} to pass additional values in the
      environment of the \code{./configure} script.
    \item \code{<pkg>_CONF_OPTS} to pass additional options to the
      \code{./configure} script.
    \item \code{<pkg>_INSTALL_OPTS}, \code{<pkg>_INSTALL_STAGING_OPTS}
      and \code{<pkg>_INSTALL_TARGET_OPTS} to adjust the {\em make}
      target and options used for the installation.
    \item \code{<pkg>_AUTORECONF}. Defaults to \code{NO}, can be set
      to \code{YES} if regenerating \code{Makefile.in} files and
      \code{configure} script is needed. The infrastructure will
      automatically make sure {\em autoconf}, {\em automake}, {\em
        libtool} are built.
    \item \code{<pkg>_GETTEXTIZE}. Defaults to \code{NO}, can be set
      to \code{YES} to {\em gettextize} the package. Only makes sense
      if \code{<pkg>_AUTORECONF = YES}.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Canonical \code{autotools-package} example}
  \begin{block}{libyaml.mk}
\begin{minted}[fontsize=\scriptsize]{make}
################################################################################
#
# libyaml
#
################################################################################

LIBYAML_VERSION = 0.2.5
LIBYAML_SOURCE = yaml-$(LIBYAML_VERSION).tar.gz
LIBYAML_SITE = http://pyyaml.org/download/libyaml
LIBYAML_INSTALL_STAGING = YES
LIBYAML_LICENSE = MIT
LIBYAML_LICENSE_FILES = License
LIBYAML_CPE_ID_VENDOR = pyyaml

$(eval $(autotools-package))
$(eval $(host-autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{More complicated \code{autotools-package} example}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{make}
GNUPG2_VERSION = 2.4.7
GNUPG2_SOURCE = gnupg-$(GNUPG2_VERSION).tar.bz2
GNUPG2_SITE = https://gnupg.org/ftp/gcrypt/gnupg
GNUPG2_LICENSE = GPL-3.0+
GNUPG2_LICENSE_FILES = COPYING
GNUPG2_CPE_ID_VENDOR = gnupg
GNUPG2_CPE_ID_PRODUCT = gnupg
GNUPG2_DEPENDENCIES = zlib libgpg-error libgcrypt libassuan libksba libnpth \
        $(if $(BR2_PACKAGE_LIBICONV),libiconv) host-pkgconf

ifeq ($(BR2_PACKAGE_BZIP2),y)
GNUPG2_CONF_OPTS += --enable-bzip2 --with-bzip2=$(STAGING_DIR)
GNUPG2_DEPENDENCIES += bzip2
else
GNUPG2_CONF_OPTS += --disable-bzip2
endif

ifeq ($(BR2_PACKAGE_GNUTLS),y)
GNUPG2_CONF_OPTS += --enable-gnutls
GNUPG2_DEPENDENCIES += gnutls
else
GNUPG2_CONF_OPTS += --disable-gnutls
endif
\end{minted}
\end{block}
\column{0.5\textwidth}
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{make}
[...]

ifeq ($(BR2_PACKAGE_LIBUSB),y)
GNUPG2_CONF_ENV += CPPFLAGS="$(TARGET_CPPFLAGS)
                            -I$(STAGING_DIR)/usr/include/libusb-1.0"
GNUPG2_CONF_OPTS += --enable-ccid-driver
GNUPG2_DEPENDENCIES += libusb
else
GNUPG2_CONF_OPTS += --disable-ccid-driver
endif

ifeq ($(BR2_PACKAGE_READLINE),y)
GNUPG2_CONF_OPTS += --with-readline=$(STAGING_DIR)
GNUPG2_DEPENDENCIES += readline
else
GNUPG2_CONF_OPTS += --without-readline
endif

$(eval $(autotools-package))
      \end{minted}
    \end{block}
  \end{columns}
\end{frame}

\subsection{Target vs. host packages}

\begin{frame}{Host packages}

  \begin{itemize}
  \item As explained earlier, most packages in Buildroot are
    cross-compiled for the target. They are called {\bf target
      packages}.
  \item Some packages however may need to be built natively for the
    build machine, they are called {\bf host packages}. They can be
    needed for a variety of reasons:
    \begin{itemize}
    \item Needed as a tool to build other things for the
      target. Buildroot wants to limit the number of host utilities
      required to be installed on the build machine, and wants to ensure
      the proper version is used. So it builds some host utilities by
      itself.
    \item Needed as a tool to interact, debug, reflash, generate images,
      or other activities around the build itself.
    \item Version dependencies: building a Python interpreter for the
      target needs a Python interpreter of the same version on the
      host.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Target vs. host: package name and variable prefixes}
  \begin{itemize}
  \item Each package infrastructure provides a \code{<foo>-package}
    macro and a \code{host-<foo>-package} macro.
  \item For a given package in \code{package/baz/baz.mk},
    \code{<foo>-package} will create a package named \code{baz} and
    \code{host-<foo>-package} will create a package named
    \code{host-baz}.
  \item \code{<foo>-package} will use the variables prefixed with
    \code{BAZ_}
  \item \code{host-<foo>-package} will use the variables prefixed with
    \code{HOST_BAZ_}
  \end{itemize}
\end{frame}

\begin{frame}{Target vs. host: variable inheritance}
  \begin{itemize}
  \item For many variables, when \code{HOST_BAZ_<var>} is not defined,
    the package infrastructure {\em inherits} from \code{BAZ_<var>}
    instead.
    \begin{itemize}
    \item True for \code{<PKG>_SOURCE}, \code{<PKG>_SITE},
      \code{<PKG>_VERSION}, \code{<PKG>_LICENSE},
      \code{<PKG>_LICENSE_FILES}, etc.
    \item Defining \code{<PKG>_SITE} is sufficient, defining
      \code{HOST_<PKG>_SITE} is not needed.
    \item It is still possible to override the value specifically for
      the host variant, but this is rarely needed.
    \end{itemize}
  \item But not for all variables, especially commands
    \begin{itemize}
    \item E.g. \code{HOST_<PKG>_BUILD_CMDS} is not inherited
      from \code{<PKG>_BUILD_CMDS}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example 1: a pure build utility}
  \begin{itemize}
  \item {\em bison}, a general-purpose parser generator.
  \item Purely used as build dependency in packages
    \begin{itemize}
    \item \code{FBSET_DEPENDENCIES = host-bison host-flex}
    \end{itemize}
  \item No \code{Config.in.host}, not visible in \code{menuconfig}.
  \end{itemize}
  \begin{block}{package/bison/bison.mk}
\begin{minted}[fontsize=\tiny]{make}
BISON_VERSION = 3.8.2
BISON_SOURCE = bison-$(BISON_VERSION).tar.xz
BISON_SITE = $(BR2_GNU_MIRROR)/bison
BISON_LICENSE = GPL-3.0+
BISON_LICENSE_FILES = COPYING
BISON_CPE_ID_VENDOR = gnu
# parallel build issue in examples/c/reccalc/
BISON_MAKE = $(MAKE1)
HOST_BISON_DEPENDENCIES = host-m4
HOST_BISON_CONF_OPTS = --enable-relocatable
HOST_BISON_CONF_ENV = ac_cv_libtextstyle=no

$(eval $(host-autotools-package))
\end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Example 2: filesystem manipulation tool}

  \begin{itemize}
  \item \code{fatcat}, is designed to manipulate FAT filesystems, in
    order to explore, extract, repair, recover and forensic them.
  \item Not used as a build dependency of another package
    $\rightarrow$ visible in \code{menuconfig}.
  \end{itemize}
  \begin{block}{package/fatcat/Config.in.host}
    \tiny
\begin{verbatim}
config BR2_PACKAGE_HOST_FATCAT
        bool "host fatcat"
        help
          Fatcat is designed to manipulate FAT filesystems, in order
          to explore, extract, repair, recover and forensic them. It
          currently supports FAT12, FAT16 and FAT32.

          https://github.com/Gregwar/fatcat
\end{verbatim}
  \end{block}

  \begin{block}{package/fatcat/fatcat.mk}
    \begin{minted}[fontsize=\tiny]{make}
FATCAT_VERSION = 1.1.1
FATCAT_SITE = $(call github,Gregwar,fatcat,v$(FATCAT_VERSION))
FATCAT_LICENSE = MIT
FATCAT_LICENSE_FILES = LICENSE

$(eval $(host-cmake-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Example 3: target and host of the same package}
  \begin{block}{package/e2tools/e2tools.mk}
    \begin{minted}[fontsize=\tiny]{make}
E2TOOLS_VERSION = 0.0.16.4
E2TOOLS_SITE = $(call github,ndim,e2tools,v$(E2TOOLS_VERSION))

# Source coming from GitHub, no configure included.
E2TOOLS_AUTORECONF = YES
E2TOOLS_LICENSE = GPL-2.0
E2TOOLS_LICENSE_FILES = COPYING
E2TOOLS_DEPENDENCIES = e2fsprogs
E2TOOLS_CONF_ENV = LIBS="-lpthread"
HOST_E2TOOLS_DEPENDENCIES = host-e2fsprogs
HOST_E2TOOLS_CONF_ENV = LIBS="-lpthread"

$(eval $(autotools-package))
$(eval $(host-autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\setuplabframe
{New packages in Buildroot}
{
  \begin{itemize}
  \item Practical creation of several new packages in Buildroot, using
    the different package infrastructures.
  \end{itemize}
}
