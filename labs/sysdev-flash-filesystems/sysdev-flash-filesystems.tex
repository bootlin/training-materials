\subchapter{Filesystems - Flash file systems}{Objective: Understand flash and flash file systems usage and their integration on the target}

After this lab, you will be able to:
\begin{itemize}
\item Prepare filesystem images and flash them.
\item Define partitions in embedded flash storage.
\end{itemize}

\section{Setup}

Stay in \code{$HOME/embedded-linux-labs/tinysystem}. Install the
\code{mtd-utils} package, which will be useful to create UBIFS and
UBI images.

\section{Goals}

Instead of using an external MMC card as in the previous lab, we will
make our system use its internal flash storage.

We will create an MTD partition to be attached to the UBI layer (the partitions
previously used to store the kernel image and the DTB should be merged
with this UBI partition).

The kernel and DTB images will be stored in two separate {\em static}
(read-only) UBI volumes.

The root filesystem will be a UBI volume storing a UBIFS filesystem
mounted read-only, the web server upload data will be stored in
another UBI volume storing a UBIFS filesystem mounted
read/write. These volumes will be {\em dynamic} volumes and will be
16 MiB large.

Which gives the following layout:

\begin{center}
  \includegraphics[width=\textwidth]{labs/sysdev-flash-filesystems/flash-map.pdf}
\end{center}

\section{Enabling NAND flash and filesystems}

First, make sure your kernel has support for UBI and UBIFS, and also
the option allowing us to pass the partition table through the command
line:
(\code{CONFIG_MTD_CMDLINE_PARTS}).

Recompile your kernel if needed. We will update your kernel image on flash
in the next section.

\section{Filesystem image preparation}

To prepare filesystem images, we won't use what you stored on the MMC/SD
card during the previous lab. We will get back to the filesystem sources
that you have in \code{$HOME/embedded-linux-labs/tinysystem/nfsroot}.

To run \code{mkfs.ubifs}, you will need to find the Logical Erase
Block (LEB) size that UBI will use.

A solution to get such information is to list default MTD partitions
on the target (\code{cat /proc/mtd}), and attach the last partition
to UBI. In case, the last partition is \code{mtd5}, you will run:

\begin{verbatim}
ubiattach -m 5 /dev/ubi_ctrl
\end{verbatim}

Doing this, you will get details in the kernel log about the MTD minimum
I/O size and the LEB size that UBI will use\footnote{Note that this command
could fail if you accidently wrote to the corresponding flash blocks.
If this happens, go back to U-Boot and erase NAND sectors from the
starting offset of this partition: \code{nand erase 0x660000 0xF9A0000}}.

Knowing that the \code{data} and \code{rootfs} UBI volumes will be 16
MiB big, you can now divide their total size by the LEB size, to compute
the maximum of LEBs that they will contain. That's the last parameter
(\code{-c}) that you need to pass to \code{mkfs.ubifs}.

You can now prepare a UBIFS filesystem image containing the files
stored in the \code{www/upload/files} directory.

Modify the \code{etc/init.d/rcS} file under \code{nfsroot} to mount a
UBI volume called \code{data} \footnote{We will create it when
running \code{ubinize} in the next section} on \code{www/upload/files}.

Once done, create a UBIFS image of your root filesystem.

\section{UBI image preparation}

Create a \code{ubinize} config file where you will define the 4 volumes
described above, then use the \code{ubinize} tool to generate your
UBI image.

Warning: do not use the autoresize flag (\code{vol_flags=autoresize}):
U-Boot corrupts the UBI metadata when trying to expand the volume.

Remember that some of these volumes are static (read-only) and some are
not.

%Creating UBIFS images:
%
%mkfs.ubifs -d <rootfs-directory-path> -o <rootfs-image-path> -e 124KiB -m 2048 -c 1024
%mkfs.ubifs -d <data-directory-path> -o <data-image-path> -e 124KiB -m 2048 -c 1024
%

%
% ubi config file contents
%
%[kernel]
%mode=ubi
%image=<zImage-path>
%vol_id=1
%vol_type=static
%vol_name=kernel
%
%[dtb]
%mode=ubi
%image=<dtb-path>
%vol_id=2
%vol_type=static
%vol_name=dtb
%
%[root]
%mode=ubi
%image=<rootfs-image-path>
%vol_id=3
%vol_type=dynamic
%vol_size=16MiB
%vol_name=root
%
%[data]
%mode=ubi
%image=<data-image-path>
%vol_id=4
%vol_type=dynamic
%vol_size=16MiB
%vol_name=data
%

%
% Creating UBI images:
%
% # ubinize -o test.ubi -p 128KiB -m 2048 ubi.ini
%

\section{MTD partitioning and flashing}

Look at the default MTD partitions in the kernel log. They do not
match the way we wish to organize our flash
storage. Therefore, we will define our own partitions at boot time,
on the kernel command line.

Redefine the partitions in U-Boot using the \code{mtdids} and
\code{mtdparts} environment variables.
Once done, execute the \code{mtdparts} command and check the partition
definitions.

You can now safely erase the UBI partition without risking any
corruption on other partitions.

Download the UBI image (using \code{tftp}) you have created in the
previous section and flash it on the UBI partition.

When flashing the UBI image, use the \code{trimffs} version of the
command \code{nand write}\footnote{The command \code{nand write.trimffs} skips
  the blank sectors instead of writing them. It is needed because the
  algorithm used by the hardware ECC for the SAMA5D3 SoC generates a
  checksum with bytes different from \code{0xFF} if the page is blank. Linux
  only checks the page, and if it is blank it doesn't erase it, but as
  the OOB is not blank it leads to ECC errors. More generally it is
  not recommended writing more than one time on a page and its OOB
  even if the page is blank.}.

\section{Loading kernel and DTB images from UBI and booting it}

From U-Boot, retrieve the kernel and DTB images from their respective
UBI volumes and try to boot them. If it works, you can modify your
\code{bootcmd} accordingly.

Set the \code{bootargs} variable so that:

\begin{itemize}
\item The \code{mtdparts} environment variable contents are passed to
  the kernel through its command line. 
\item The UBI partition is automatically attached to the UBI layer at
  boot time
\item The root filesystem is mounted from the root volume, and is mounted
  read-only (kernel parameter \code{ro}).
\end{itemize}

Boot the target, and check that your system still works as
expected. Your root filesystem should be mounted read-only, while the
data filesystem should be mounted read-write, allowing you to upload
data using the web server.

%Useful u-boot environment variables
%setenv mtdids nand0=atmel_nand
%setenv mtdparts mtdparts=atmel_nand:256k(bootstrap),512k(u-boot),256k(u-boot-env1),256k(u-boot-env2),-(UBI)
%setenv bootargs_base console=ttyS0,115200 rootfstype=ubifs root=ubi0:root ip=192.168.0.100:::::eth0 ubi.mtd=4 ro
%setenv bootcmd 'mtdparts; ubi part UBI; ubi readvol 0x21000000 kernel;
%ubi readvol 0x22000000 dtb; setenv bootargs ${bootargs_base} ${mtdparts}; bootz 0x21000000 - 0x22000000'
%setenv flash 'mtdparts; nand erase.part UBI; tftp 0x21000000 test.ubi; nand write.trimffs 0x21000000 UBI ${filesize}'

\section{Going further}

\subsection{Using {\em squashfs} for the root filesystem}

Root filesystems are often a sensitive part of your system, and you don't
want it to be corrupted, hence some people decide to use a read-only
file system for their rootfs and use another file system to store their
auxiliary data.

\code{squashfs} is one of these read-only file systems. However,
\code{squashfs} expects to be mounted on a block device.

Use the {\em ubiblk} layer to emulate a read-only block device on top
of a static UBI volume to mount a {\em squashfs} filesystem as the
root filesystem:

\begin{itemize}
  \item First create a {\em squashfs} image with your rootfs contents
  \item Then create a new static volume to store your squashfs and update it with
    your squashfs image
  \item Enable and setup the {\em ubiblk} layer
  \item Boot on your new rootfs
\end{itemize}

%TODO: provide a solution

\subsection{Atomic update}

UBI also provides an atomic update feature, which is particularly useful
if you need to safely upgrade sensitive parts of your system (kernel,
DTB or rootfs).

Duplicate the kernel volume and create a U-Boot script to fallback on
the second kernel volume if the first one is corrupted:
\begin{itemize}
  \item First create a new static volume to store your kernel backup
  \item Flash a valid kernel on the backup volume
  \item Modify your \code{bootcmd} to fallback to the backup volume if the first one
    is corrupted
  \item Now try to update the kernel volume and interrupt the process before
    it has finished and see what happens (unplug the platform)
  \item Create a shell script to automate kernel updates (executed in Linux).
    Be careful, this script should also handle the case where the backup
    volume has been corrupted (copy the contents of the kernel volume into
    the backup one)
\end{itemize}

%TODO: provide a solution
