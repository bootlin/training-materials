\subchapter{Kernel compiling and booting}{Objective: compile and boot
a kernel for your board, booting on a directory on your workstation
shared by NFS.}

After this lab, you will be able to:
\begin{itemize}

\item Cross-compile the Linux kernel for the ARM platform.

\item Boot this kernel on an NFS root filesystem, which is somewhere
on your development workstation\footnote{NFS root filesystems are
particularly useful to compile modules on your host, and make them
directly visible on the target. You no longer have to update the root
filesystem by hand and transfer it to the target (requiring a shutdown
and reboot).}.

\end{itemize}

\section{Lab implementation}

While developing a kernel module, the developer wants to change the
source code, compile and test the new kernel module very
frequently. While writing and compiling the kernel module is done on the
development workstation, the test of the kernel module usually has to
be done on the target, since it might interact with hardware specific
to the target.

However, flashing the root filesystem on the target for every test is
time-consuming and would use the flash chip needlessly.

Fortunately, it is possible to set up networking between the
development workstation and the target. Then, workstation files can be
accessed through the network by the target, using NFS.

\begin{center}
\includegraphics[width=\textwidth]{labs/kernel-compiling-and-nfs-booting-stm32mp1/host-vs-target.pdf}
\end{center}

\section{Setup}

Go to the \code{$HOME/__SESSION_NAME__-labs/src/linux} directory.

Install packages needed for configuring, compiling and booting
the kernel for your board:

\begin{verbatim}
sudo apt install libssl-dev bison flex
\end{verbatim}

\section{Cross-compiling toolchain setup}

We are going to install a cross-compiling toolchain provided by Bootlin:

\scriptsize
\begin{verbatim}
wget -P $HOME https://toolchains.bootlin.com/downloads/releases/toolchains/armv7-eabihf/tarballs/armv7-eabihf--glibc--stable-2024.05-1.tar.xz
tar xvf $HOME/armv7-eabihf--glibc--stable-2024.05-1.tar.xz -C $SHOME
\end{verbatim}
\normalsize


To find out the path and name of the cross-compiler executable looking at the contents of the following directory:

\begin{verbatim}
ls $HOME/armv7-eabihf--glibc--stable-2025.08-1/bin
\end{verbatim}

\section{Kernel configuration}

Set the \code{ARCH} and \code{CROSS_COMPILE} definitions for the \code{arm}
platform and your cross-compiler.

There is one default configuration for our platform, which is called
\code{multi_v7_defconfig}. Apply this configuration, then run \code{make menuconfig}.

\begin{itemize}
\item Disable \kconfig{CONFIG_GCC_PLUGINS} if it is set. This will skip
  building special {\em gcc} plugins, which would require extra dependencies
  for the build.
\item In the \code{Platform Selection} menu, remove support for all the SoCs except
 the STM32157 ones. Donâ€™t forget to disable the TI ones too which are in a submenu.
\item Disable \kconfig{CONFIG_DRM}, which will skip support for many display
controller and GPU drivers.
\end{itemize}

Please note that this will definitely not build the smallest and most optimized kernel for STM32MP1:
\code{multi_v7_defconfig} enables plenty of features and drivers that will not be useful on our particular board.

\section{Kernel compiling}

Compile your kernel and generate the Device Tree Binaries (DTBs)
(running 8 compile jobs in parallel):

\begin{verbatim}
make -j 8
\end{verbatim}

Now, copy the \code{zImage} and \code{stm32mp157a-dk1.dtb} files to the
TFTP server home directory (as specified in \code{/etc/default/tftpd-hpa}).

\section{Setting up the NFS server}

Install the NFS server by installing the \code{nfs-kernel-server}
package. Once installed, edit the \code{/etc/exports} file as
\code{root} to add the following lines, assuming that the IP address
of your board will be \code{192.168.0.100}:

\scriptsize
\begin{verbatim}
/home/<user>/__SESSION_NAME__-labs/modules/nfsroot 192.168.1.100(rw,no_root_squash,no_subtree_check)
\end{verbatim}
\normalsize

Of course, replace \code{<user>} by your actual user name.

Make sure that the path and the options are on the same line.
Also make sure that there is no space between the IP address and the NFS
options, otherwise default options will be used for this IP address,
causing your root filesystem to be read-only.

Then, restart the NFS server:

\begin{verbatim}
sudo exportfs -r
\end{verbatim}

If there is any error message, this usually means that there was a
syntax error in the \code{/etc/exports} file. Don't proceed until these
errors disappear.

\section{Boot the system}

First, boot the board to the U-Boot prompt. Before booting the kernel,
we need to tell it that the root filesystem should be mounted over NFS,
by setting some kernel parameters.

Do this by setting U-boot's \code{bootargs} environment variable (all in
just one line):

\begin{verbatim}
setenv bootargs root=/dev/nfs root=/dev/nfs ip=192.168.1.100
nfsroot=192.168.1.1:/home/<user>/linux-kernel-stm32mp1-labs/modules/nfsroot,nfsvers=3,tcp rw
\end{verbatim}

Once again, replace \code{<user>} by your actual user name.

Now save this definition:
\begin{verbatim}
saveenv
\end{verbatim}

If you later want to make changes to this setting, you can type the
below command in U-boot:

\begin{verbatim}
editenv bootargs
\end{verbatim}

Now, download the kernel image through \code{tftp}:

\begin{verbatim}
tftp 0xc2000000 zImage
\end{verbatim}

You'll also need to download the device tree blob:

\begin{verbatim}
tftp 0xc4000000 stm32mp157a-dk1.dtb
\end{verbatim}

Now, boot your kernel:

\begin{verbatim}
bootz 0xc2000000 - 0xc4000000
\end{verbatim}

If everything goes right, you should reach a login prompt (user:
\code{root}, password: \code{root}). Otherwise, check your setup and
ask your instructor for support if you are stuck.

If the kernel fails to mount the NFS filesystem, look carefully at the
error messages in the console. If this doesn't give any clue, you can
also have a look at the NFS server logs in \code{/var/log/syslog}.

\section{Checking the kernel version}

It's often a good idea to make sure you booted the right kernel.
By mistake, you could have booted a kernel previously stored in flash
(typically through a default boot command in U-Boot), or forgotten to
update the kernel image in the TFTP server home directory.

This could explain some unexpected behavior.

There are two ways of checking your kernel version:
\begin{itemize}
\item By looking at the first kernel messages
\item By running the \code{uname -a} command after booting Linux.
\end{itemize}

In both cases, you will not only know the kernel version, but also
the date when the kernel was compiled and the name of the user who
did it.

Similarly, you can also check the command line actually received by
the kernel, either by looking at the first boot messages, or once you
have reached a command line shell, by running \code{cat /proc/cmdline}.

\section{Automate the boot process}

To avoid typing the same U-boot commands over and over again each time
you power on or reset your board, you can use U-Boot's \code{bootcmd}
environment variable:

{\footnotesize
\begin{verbatim}
setenv bootcmd 'tftp 0xc2000000 zImage; tftp 0xc4000000 stm32mp157a-dk1.dtb; bootz 0xc2000000 - 0xc4000000'
saveenv
\end{verbatim}
}

Don't hesitate to change it according to your exact needs.

We could also copy the \code{zImage} file to the SD card and avoid
downloading it over and over again. However, detailed bootloader
usage is outside of the scope of this course. See our
\href{https://bootlin.com/training/embedded-linux/}{Embedded
Linux system development course} and its on-line materials for
details.

\section{Save your kernel configuration}

Now that you have a working (and satisfying) kernel configuration, you
can save it under the \code{configs} folder:

\begin{verbatim}
make savedefconfig
cp defconfig arch/arm/configs/stm32mp1_defconfig
\end{verbatim}

So if you later overwrite the \code{.config} file inadvertently, you can
just get back to a working configuration by running:

\begin{verbatim}
make stm32mp1_defconfig
\end{verbatim}
